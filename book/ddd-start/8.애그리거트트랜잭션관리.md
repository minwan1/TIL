# 애그리거트 트랜잭션관리


## 애그리거트와 트랜잭션
한 주문 애그러이트에 대해 운영자는 배송 준비 상태로 변경할 때 사용자는 배송지 주소를 변경하면 어떻게 될까 ? 
![](https://i.imgur.com/iSCXdTO.png)
[한 애그리거트를 두 사용자가 거의 동시에 변경할 때 트랜잭션이 필요하다.]

위상황은 각각 다른 트랜잭션에서 같은 애그리거트에 접근했을때 문제점을 보여주는 그림이다. 예를들어 배송주문 정보는 배송 준비에만 가능하다. 그래서 지금 상태는 배송 준비전이기 떄문에 유저는 배송정보를 변경하려한다. 하지만 운영자는 배송이 이제 출발하기 시작했기때문에 배송정보를 변경하려고한다. 불행히도 이 커밋은 동시에 일어났다. 이렇게 되면 애그리거트의 일관성이 깨지게 된다.

이런 문제가 발생하지 않으려면 두가지중 하나를 해야한다.

* 운영자가 배송지 정보를 조회하고 상태를 변경하는 동안 고객이 애그리거트를 수정하지 못하게 막는다.
* 운영자가 배송지 정보를 조회한 이후에 고객이 정보를 변경하면 운영자가 애그리거트를 다시 조회한뒤 수정하도록 한다.

애그리거트에 대해 사용할 수 있는 대표적인 트랜잭션 처리 방식에는 선점 잠금과 비선점 잠금의 두 가지 방식이 있는데 이어서 보자.

## 선점 잠금
선점 잠금은 먼저 애그리거트를 스레가 애그리거트 사용이 끝날 때 까지 다른 스레드가 해당 애그리거트를 수정하는것을 막는 방식이다. 아래 그림은 선정 방식을 보여주고 있다.

![](https://i.imgur.com/q9qBv7n.png)

스레드 1 이 선점 잠금 방식으로 애그리거트를 구한뒤 이어서 스레드 2가 같은 애그리거트를 구하고 있는데, 이경우 스레드 1에 대한 잠금이 풀릴떄까지 스레드2는 같은 애그리거트에 접근할 수 없다.

한스레드가 애거리거트를 구하고 수정하는동안 다른 스레드가 수정할 수 없으므로 동시에 애그리거트를 수정할 때 발생하는 충돌문제는 해소 할 수 있음,

선점 잠금은 보통 DBMS가 제공하는 행 단위 잠금을 사용해서 구현한다. 오라클을 비롯한 다수 DBMS가 for update와 같은 쿼리를 사용해서 특정 레코드에 한 사용자만 접근할 수 있는 잠금 장치를 제공한다.

JPA의 Entity는 LockModeType을 인자로 받는 find 메소드를 제공하는데 LockModeType.PESSIMISTIC_WRITE를 값으로 전달하면 해당 엔터티와 매핑된 테이블을 이용해서 선점 잠금 방식을 적용할 수 있다.

```java
Order order = entityManager.find(Order.class, orderNo, LockModeType.PERSSIMISTIC_WRITE);
```

JPA 프로바이더와 DBMS에 따라 잠금 모드의 구현이 다른데, 하이버네이트의 경우 PERSSIMISTIC_WRITE를 잠금 모드로 사용한다면 'for update' 쿼리를 사용해서 선점 잠금을 구현한다.

### 선전 잠금과 교착 상태
선점 잠금 기능을 사용할 때는 잠금 순서에 따른 교착상태가 발생하지 않도록 주의해야한다. 예를들어 다음과 같은 순서로 두 스레드가 잠금 시도를 한다고 해보자.

1. 스레드 1 : A 애그리거트에 대한 선점 잠금 구함
2. 스레드 2 : B 애그리거트에 대한 선점 잠금 구함
3. 스레드 1 : B 애그리거트에 대한 선점 잠금 시도
4. 스레드 2 : A 애그리거트에 대한 선점 잠금 시도

이렇게 되면 스레드 1은 영원히 B애그리거트에 접근을 못할것이고, 스레드 2는 A에 접근을 못할것이다. 두 스레드는 상대방 스레드가 먼저 선점함 잠금을 구할 수 없어 더이상 다음단계를 진행못하는 데드락 교착 상태에 빠진다.

선점 잠금 방식에 따른 교착 상태는 상대적으로 사용자 수가 많을 때 발생할 가능성이 많다.이런 문제를 발생하지 않도록 하려면 잠금을 구할 때 최대 대기시간을 지정해야한다. JPA에서 선점 잠금을 시도할 때 최대 대기 시간을 지정하려면 다음과 같이 힌트를 사용하면된다.

```java
Map<String, Object> hints = new HashMap();
hints.put("javx.persistence.lock.timeout",2000);
Order order = entityManager.find(Order.class, orderNo, LcokModeType.PERSSIMISTIC_WRITE, hints);
```

JPA의 'javax.persitence.lock.timeout'힌트는 잠금을 구하는데 대기시간을 밀리초 단위로 지정한다.지정한 시간내에 잠금을 구하지 못하면 익셉션을 발생시킨다. 이 힌트를 사용할떄 해당 DBMS가 힌트를 지원하는지 확인을 해야한다는것이다.

## 비선점 잠금
선점 잠금이 강력해보이긴 하지만 선점잠금으로 모든 트랜잭션 충돌 문제가 해결되는것은아니다.

![선점잠금으로 해결할수 없는 상황]![선점잠금으로 해결할수 없는 상황](/assets/선점잠금으로%20해결할수%20없는%20상황_cdy1udc3v.jpg)

1. 운영자는 배송을 위해 주문 정보를 조회한다. 시스템은 정보를 제공한다.
2. 고객이 배송지 변경을 위해 변경 폼을 요청한다. 시스템은 정보를 제공한다.
3. 고객이 새로운 배송지를 입력하고 폼을 전송해서 배송지를 변경한다.
4. 운영자가 1번에서 조회한 주문 정보를 기준으로 배송지를 정하고 배송 상태 변경을 요청한다.


