# CPU 스케줄링

### 1. 각각 명령어 
CPU는 프로그램의 기계어 명령을 실제로 수행하는 컴퓨터 내의 중앙 처리 장치이다. 프로그램이 시작되어 메모리에 올라가면, 프로그램 카운터라는 이름의 레지스터가 현재 CPU에서 수행할 코드의 메모리 주소값을 가지고 있게 된다. 그러면 CPU는 프로그램 카운터가 가리키는 주소의 기계어 명령을 하나씩 수행한다.

CPU관리에 앞서 프로그램 실행과 관련된 몇가지 기계어 명령에 대해 알아보자. 기계어명령은 크게 CPU내에서 수행되는 명령, 메모리 접근을 필요로 하는 명령, 입출력 동반으로 하는 명령으로 나눌 수 있다.

#### CPU내에서 수행되는 명령
예로는 Add 명령을 들 수 있다. Add 명령은 CPU내의 레지스터에 있는 두값을 더해 레지스터에 저장하는 명령이다. 이러한 명령은 CPU내에서만 수행되므로 명령의 수행속도가 매우 빠르다. 

#### 메모리 접근 수행 명령
메모리 접근을 수행하는 명령으로 Load와 Sotre명령이 있다. Load명령은 메모리에 있는 데이터를 CPU로 읽어 들이는 명령이다. Store명령은 CPU에서 계산된 결과값을 메모리에 저장하는 명령이다. 메모리를 접근하는 명령은 비록 CPU 내에서 수행되는 명령보다 시간이 오래 소요되지만 비교적 짧은 시간에 수행할 수 있는 명령이다. **또한 CPU내에서 일어나는 명령이나 메모리를 접근하는 명령은 사용자 프로그램이 직접 실행가능한 일반 명령이다.**


#### 입출력 작업 명령
사용자 프로그램이 수행되다 보면 입출력작업이 필요한 경우가 발생한다. 키보드로부터 입력을 받는다등에 작업을 하기위해서는 운영체제를 거쳐야한다. 이러한 작업은 CPU나 메모리접근 명령에 비해 오랜시간이 걸린다. 또한, 컴퓨터 시스템에서는 모든 입출력 명령을 특권 명령으로 규정해 사용자 프로그램이 직접 수행할 수 없도록 하고 운영체제를 통해 서비스를 대행하도록 하고 있다.

### 2. CPU버스트 / I/O버스트
위와같이 프로그램의 수행을 서로 다른 두 단계의 조합인 CPU버스트와 I/O버스트로 나누어질 수 있다.
**CPU 버스트** : 사용자 프로그램이 CPU를 직접 가지고 빠른 명령을 수행하는 일련의 단계이다. 쉽게 생각해 사용자 프로그램이 CPU를 할당받고 처리하고있는 과정을 CPU 버스트라고 생각하면 된다.
**I/O 버스트** : I/O 요청이 발생해 커널에 의해 입출력 작업을 진행하는 비교적 느린 단계이다. 즉 I/O작업이 요청된 후 완료되어 다시 CPU 버스터로 돌아가기까지의 일어나는 일련의 작업을 말한다.


### 3. I/O바운드 프로세스 / CPU바운드 프로세스
각 프로그램마다 CPU버스트와 I/O 버스트가 차지하는 비율이 균일 하지는 않다. 어떤 프로세스는 I/O버스트가 빈번하고, 어떤 프로세스는 I/O버스트가 빈번하다. 이와 같은 기준에서 프로세스를 크게 **I/O바운드 프로세스**와 **CPU바운드 프로세스**로 나누어 볼 수 있다.

#### I/O바운드 프로세스
I/O요청이 빈번해 CPU버스트가 짧게 나타나는 프로세스를 말하고,  I/O바운드 프로세스는 주로 사용자로부터 인터액션을 계속 받아가며 프로그램을 수행시키는 대화형 프로그램이 이에해당한다.

#### CPU바운드 프로세스
CPU바운드 프로세스는 I/O 작업을 거의 수행하지 않아 CPU버스트가 길게 나타나는 프로세스를 말한다. 프로세스 수행의 상당 시간을 입출력 작업 없이 CPU작업에 소모하는 계산 위주의 프로그램이 이에 해당한다. 


### 4. CPU 스케줄링이란
프로그램이 수행되는 구조를 보면 I/O바운드 프로세스는 짧은 CPU 버스트를 많이 가지고 있는 반면, CPU 바운드 프로세스는 소수의 긴 CPU버스트로 구성된다. **CPU스케줄링이란** 이와 같이 CPU를 사용하는 패턴이 상이한 여러 프로그램이 동일한 시스템 내부에서 함께 실행되기 때문에 필요한것이다. 우리가 사용하는 시분할 시스템에서는 이와같이  CPU버스트가 균일하지 않은 다양한 프로그램이 공존하므로 효율적인 CPU스케줄링 기법이 반드시 필요하다.

컴퓨터 시스템 내에서 수행되는 프로세스들의 CPU버스트를 분석해보면 대부분의 경우 짧은 CPU 버스트를 가지며, 극히 일부분만 긴 CPU버스트를 가진다. 이러한 이유는 사용자에게 입력을 받아 CPU연산을 수행하고 그 결과를 다시 출력하는 작업을 수행하는 프로세스들이 많기 때문이다. 즉 대화형 작업이 많다는 의미이다. 이는 바꾸어 말하면 CPU 스케줄링시 **I/O바운드 프로세스**에게 우선순위를 높여주는것이 바람직하다는 의미가 된다. 

#### I/O바운드프로세스에게 CPU를 우선적으로 사용할 수 있을 때 장점
이러한 스케줄링은 대화형 프로세스의 빠른 응답성 제공외에 I/O 장치의 효율성을 높이는 효과도 얻을 수 있다. I/O바운드 프로세스에게 먼저 CPU를 할당할 경우 CPU를 잠깐만 사용한 후 곧바로 I/O 작업을 수행할 수 있으므로, I/O장치의 이용률이 높아지기 때문이다. 
#### CPU바운드프로세스에게 CPU를 우선적으로 사용할 수 있을 때 단점
만약 CPU 바운드 프로세스에게 먼저 CPU를 할당 한다면 그 프로세스가 CPU를 다 사용할 때까지 I/O바운드 프로세스는 응답 시간이 길어질 뿐 아니라 해당 I/O장치도 그 시간동안 작업을 수행하지 않는 휴면 상태가 된다.


## CPU 스케줄러
CPU 스케줄러는 준비 상태에 있는 프로세스들중에 어떠한 프로세스에게 CPU를 할당할지를 결정하는 운영체제의 코드이다. CPU 스케줄러는 타이머인터럽트등이 발생하면 호출된다. 그렇게되면 스케줄러는 준비큐에 하나를 꺼내서 CPU를 할당하고 작을 수행한다. 
이밖에도 CPU 스케줄링이 필요한 경우가 다음과 같이 있다.

1. 실행 상태에 있던 프로세스가 I/O 요청 등에 의해 봉쇄(blocked) 상태로 바뀌는 경우
2. 실행 상태에 있던 프로세스가 타이머 인터럽트 발생에 의해 준비 상태로 바뀌는 경우
3. I/O 요청으로 봉쇄 상태에 있던 프로세스의 I/O 작업이 완료되어 인터럽트가 발생하고 그결과 이 프로세의 상태가 준비 상태로 바뀌는 경우
4. CPU에서 실행 상태에 있는 프로세스가 종료되는 경우

CPU 스케줄링 방식에는 비선점형 방식과 선점형 방식이 있다.

**선점형 방식** 
* 프로세스가 CPU를 계쏙 사용하기를 원하더라도 강제로 빼앗을 수 있는 스케줄링 방법
* CPU를 뺴앗는 대표적인 예로는 타이머인터럽트가 있다.
* 위에서 예에서 2,3이 선점형 스케줄링에 해당한다.

**비선점형 방식**
* CPU를 획득한 프로세스가 스스로 CPU를 반납하기 전까지는 CPU를 빼앗기지 않는 방법
* 위에서 예로는 1,4가 해당한다.

## 디스패처
새롭게 선택된 프로세스가 CPU를 할당받고 작업을 수행할 수 있도록 환경 설정을 하는 커널 모듈을 `디스패처(dispatcher)`라고 한다.
* 디스패처는 현재 수행중이던 프로세스의 문맥을 프로세의 PCB에 저장하고, 새롭게 선택된 프로세의 문맥을 PCB로부터 복원한 후 그 프로세스에 CPU를 넘기는 과정을 수행한다.
* 새로운 프로세스의 문맥을 복원시킨후에는 사용자 모드로 시스템의 상태를 전환해 사용자 프로그램에게 CPU 제어권을 넘긴다.
* 디스패처 하나가 프로세스를 정지시키고 다른 프로세스에게 CPU를 전달하기까지 걸리는 시간을 우리는 디스패치 지연 시간이라고 부른다.


## 스케줄링 성능 평가
스케줄링 기법의 성능을 평가하기 위해 여러 지표들이 사용되는데 크게 `시스템과점 지표`와 `사용자 과점 지표`로 나뉘어진다. 시스템 관점의 지표는 CPU활용도와 처리량이며, 사용자 관점이 지표는 소요시간, 대기시간, 응답시간등이다. 이들의 지표 정의는 다음과 같다.

| 정의 | 설명 |
|-|-|
| CPU 활용도(CPU utilization) | 전체 시간 중 CPU가 명령을 수행한 시간의 비율 |
| 처리량(Throughput) | 주어진 시간동안 CPU 버스트를 완료한 프로세스의 개수 |
| 소용 시간(turnaround time) | CPU요청 시점부터 준비큐에서 기다린 시간과 프로세스가 CPU 버스트가 끝날때까지 걸린 시간(프로그램이 시작해서 종료되는것을 의미하지는 않는다.)  |
| 대기 시간(waiting time)| 프로세스가 준비 큐에서 기다린 시간의 합, 여기에서 합에 의미는 시분할 시스템 같은경우에는 CPU를 처리하다가도 다시 준비큐로 들어와 대기를 탈 수 있기 때문에 전체 준비큐에서 기다린 시간의 합을 의미한다. |
| 응답 시간 (response time) | 준비큐에 들어온 후 첫번째 CPU를 획득하기 까디 기다린 시간을 뜻한다. 즉 프로세스가 CPU 요청 시점부터 처음으로 CPU를 얻을 때까지 기다린 시간. |



## 스케줄링 알고리즘
### FCFS
`FCFS(First-Come First-Served)` 스케줄링은 프로세스가 준비 큐에 도착한 시간 순서대로 CPU를 할당하는 방식을 말한다. 용어 그대로 CPU를 먼저 요청한 프로세스에게 CPU를 먼저 할당한다.
CPU 버스트가 긴 프로세스 하나가 CPU 버스트가 짧은 프로세스 여러개 보다 먼저 도착했다고 가정해보자. **이경우 늦게 도착한 작업들은 한없이 기다려야하기 때문에 평균 대기시간이 길어진다.**

* CPU버스트가 짧은 프로세스들에게 잠깐씩만 CPU를 할당하게 되면 프로세스들이 CPU버스트를 마친뒤 I/O작업을 연이어 수행할 수 있는데 CPU버스트가 긴 프로세스가 하나 대기시간은 물론 I/O장치들의 활용도까지 동반하락한다.

이제 이 알고리즘의 성능을 예를 통해 살펴보자

| 프로세스 | CPU 버스트 시간 |
|-|-|
| P1 | 12 |
| P2 | 3 |
| P3 | 3 |

프로세스의 도착 순서가 P1,P2,P3라 하고 각각의 CPU 버스트 시간이 12, 3, 3이라고 가정할 때, FCFS에 의한 스케줄 순서를 차트로 나타내면 다음과 같다.

![](https://i.imgur.com/IezOkoh.png)

위 그래프를 FCFS스케줄러로 대기시간과 평균 대기시간을 구하면 아래와같 다.
* 대기 시간 : P1=0, P2=12, P3=15
* 평균 대기 시간 : (0+12+15)/3 = 9

다음은 프로세스의 도착 순서가 P2, P3, P1이라고할 때, 스케줄 순서를 차트로 나타내면 다음과 같다.
![](https://i.imgur.com/D4a0gAN.png)
* 대기 시간 : P1=6, P2=0, P3=3
* 평균 대기 시간 : (6+0+3)/3 = 3

두가지 경우를 비교해보면 CPU 버스트가 짧은 프로세스가 먼저 도착한 후자의 경우에 평균 대기시간이 크게 줄어들었음을 알 수 있다. 처음 FCFS처럼 긴 CPU버스트 프로세스가 앞에 있어 뒤에서 짧은 CPU버스트를 가진 프로세스가 기다리는 현상을 **콘보이 현상**이라 한다.

### SJF
SJF(Shortest-job First) 스케줄링 알고리즘은 CPU 버스트가 가장 짧은 프로세스에게 제일 먼저 CPU를 할당하는 방식이다. 이렇게 관리하면 CPU버스트가 짧은 프로세스가 CPU를 먼저 사용하고 준비큐를 빠져나가게되면 전체적인 시간이 줄어든다. **SJF 스케줄링 알고리즘은 평균 대기시간을 가장 짧게 하는 최적의 알고리즘으로 알려져있다.**

SJF 알고리즘은 비선점형 방식과 선점형 방식 두 가지로 구현될 수 있다. 
**비선점형**
CPU를 획득하면 그 프로세스가 CPU를 자진 반납하기 전까지는 CPU를 선점당하지 안흔ㄴ 방식을 말한다.
**선점형**
준비큐에서 CPU버스트가 더 짧은 프로세스가 도착할 경우 CPU를 빼앗아 더 짧은 프로세스에게 부여하는 방식을 말한다. SJF의 선점형 구현방식을 SRTF(Shortest Remaining Time First)라고도 부른다.




|프로세스|도착 시간| CPU 버스트 시간|
|-|-|-|
| P1 | 0 | 7 |
| P2 | 2 | 4 |
| P3 | 4 | 1 |
| P4 | 5 | 4 |

다음은 네 개의 프로세스 P1, P2, P3, P4가 각각 위와 같은 도착 시간과 CPU 버스트 시간을 가진다고할 때 SJF알고리즘의 스케줄링 차트 및 평균 대기 시간은 다음과 같다.


**SJF 비선점형 스케줄링**
![](https://i.imgur.com/lcvWsU7.png)

0 : P1은 처음에 도착했기 때문에 0 이다.
6 : P2는 2초에 도착했고 8초에 시작했기 때문에 6초이다.
3 : P3는 4초에 도착했고 7초에 시작했기 때문에 3초이다.
7 : P4는 5초에 도착했고 12초에 시작했기 때문에 7초이다.

* 평균 대기 시간 : (0+6+3+7)/4 = 4




**SJF 선점형 스케줄링(SRJF)**
![](https://i.imgur.com/z7USmZt.png)

선점형 방식에서는 프로세스가 새롭게 도착하거나 작업이 끝날 때마다 CPU 버스트 시간을 비교하게 된다.

9 : P1은 준비큐에서 9초간 기다리기게 된다.
1 : P2는 준비큐에서 1초간 기다리리게 된다.
0 : P3는 도착하자마자 실행되니까 0초이다.
2 : P4는 5초에 도착하여 2초대기후 실행된다.

* 평균 대기 시간 : (9+1+0+2)/4 = 3


**SJF 스케줄링 기법의 구현에서 현실적으로 어려운 부분은 프로세스의 CPU 버스트 시간을 미리 알 수 없다는점이다.** 그래서 예측을 통해 CPU 버스트 시간을 구한 후 예측치가 가장 짧은 프로세스에게 CPU를 할당한다. CPU 버스트 시간의 예측은 과거의 CPU 버스트 시간을 통해이루어지는데 다음 방법과 같다.

(n+1) 번째 CPU 버스트의 예측시간 Tn+1은 
* Tn + 1 = a tn + (1-a) Tn

tn : 실제 CPU 버스트시간
Tn : CPU 버스트 예측 시간
a : 0 <= a <=1

a값을 0과 1사이의 값으로 셋팅하면 n번째 실제 CPU버스트 시간과 n번째 버스트 시간의 예측값을 적당히 가중 평균해 n+1번째 CPU버스시간을 예측하게된다.

**SJF 알고리즘 주의사항**
**SJF 알고리즘이 평균 대기 시간을 최소화하는 알고리즘이기는 하지만 시스템에서 평균을 줄이는것이 항상 좋은 방식이 될 수 는 없다.** 예를들어 CPU 버스트 시간이 1000인데 현재 준비큐에 CPU 버스트가 10,20,30인 프로세스가 있다고해보자. 이럴경우 준비큐에 10,20,30의 버스트를 수행하고 1000의 버스트를 처리할것이다. 하지만 30까지 처리하고 또 다른 CPU버스트가 준비큐에 들어오게되고, 계속계속해서 준비큐에 1천보다 짧은 버스트 프로세스가 들어오게된다면 CPU 버스트가 1000인 프로세스는 무한정 대기를 해야한다는 취약점이 있다. 이러한 현상을 **기아 현상**이라고한다. 



### 우선순위 스케줄링

우선 순위