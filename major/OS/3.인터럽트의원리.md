## 인터럽트의 원리

### 1. 프로그램의 구조와 인터럽트
프로그램이 CPU에서 명령을 수행하려면 수행하려는 주소 영역이 메모리에 올라가 있어야한다. 이때 프로그램의 주소영역은 크게 코드, 데이터, 스택 영역으로 구분된다. 코드영역은 우리가 작성한 함수들의 코드가 기계어 명령어로 변환되어 저장되고, 데이터 영역은 전역변수등 프로그램이 사용하는 데이터들이 저장된다. 스택영역은 함수가 호출된 함수의 수행을 마치고 복귀할 주소및 지역변수등이 임시로 저장하는데 사용된다.

우리가 작성한 프로그램은 제일먼저 메인함수에 시작되는데 메인 함수가 다른 함수를 호출하면 CPU가 메인함수의 코드를 수행하다가 다른 함수의 코드로 수행 위치를 이동하게된다. 그리고 이동한 함수를 수행하고 다시 메인함수로돌아오게 된다. 이때 다시 돌아와야 하는 지점을 스택에 저장하게 된다.

인터럽트의 동작 원리도 함수의 호출과 비슷하다. A라는 프로그램이 CPU를 선점당하고 명령을 수행하고 있는데 인터럽트가 발생하면 A는 현재수행중인 명령의 위치를 저장해놓는다. 그 후 운영체제 내부 코드인 인터럽트 처리 루틴으로 넘어가서 인터럽트 처리를 하고 다시 돌아와 A의 이전 작업 지점부터 수행을 계속 이어간다. 일반적으로 프로그램에서 함수복귀 주소는 위에서 말한것처럼 스택영역에 저장한다. 반면, 인터럽터때문에 CPU가 선점당한 위치를 저장하는 공간은 운영체제 커널부분에 존재한다.

운영체제는 현재 실행중인 모든 프로그램을 관리하기 위한 자료구조를 유지하고 있다. 예를들어 A와 B두개의 프로그램이 현재 수행중이라면 커널 어딘가에 이 두 프로그램을 관리하기 위한 자료구조가 존재한다. 이 자료구조를 프로세스 제어 블록(PCB:Process Control Block)이라고 부른다. 프로세스 제어블록에는 인터럽트가 발생했을 때 그 프로그램의 어느 부분까지 수행했는지를 저장하기 위한 영역이 존재한다. 프로그램 A가 수행중에 인터럽트가 발생하면 현재 수행중이던 지점을 A의 프로세스 제어 블록에 저장한후, 인터럽트 처리 루틴으로가서 인터럽트 발생과 관련된 일을 처리한다. 인터럽트 처리를 마치면 프로그램 A의 프로세스 제어블록에 저장된 주소를 복원하여 원래 수행하던 작업을 진행한다

**프로세스 제어 블록(PCB:Process Control Block)**
운영체제에서 현재 실행중인 모든 프로그램을 관리하기 위한 자료구조이다.

### 2. 컴퓨터 시스템의 작동개요
흔히들 CPU를 컴퓨터 두뇌라고 부르지만 CPU는 실질적으로 연산 기능밖에 하지 못한다. 이는 CPU가 빠른 처리능력을 가지고있지만 어떠한 작업을 수행해야하는지는 스스로 결정하지 못한다. CPU는 보통 PC레지스터에 있는 주소를 읽어와 연산만을 수행한다. 일반적으로 조건문이나 반복문등에 의한 주소 이동이 없는 이상 프로그램 카운터는 바로 다음의 주소를 가리키게 된다.

앞장에서 말햇듯이 CPU만으로 컴퓨터 시스템이 구성되지 않는다. 프로그램이 수행되는 중에 여러가지 입출력을 수행해야한다. 이렇게 CPU에서 명령을 수행하는 부분과 외부와 입출력이 이루어지는 부분을 총체적으로 이해하기 위해서는 컴퓨터 시스템의 구성에 대해 좀 더 폭넓게 알아야한다.

컴퓨터 시스템을 구성하는 하드웨어로는 먼저 CPU와 메모리가 있고, 이밖에 갖가지 입출력장치가 있다. 그리고 이 입출력 장바리를 보조하는 버퍼와 컨트롤러들이 존재한다.

메모리에는 사용자 프로그램들과 운영체제가 같이 올라가 수행된다. 이 때 CPU는 프로그램 카운터가 가리키는 메모리 위치의 프로그램을 수행하게 된다. 예를들어 프로그램 카운터가 메모리 주소중 운영체제가 존재하는 부분을 가리키고 있으면 이 경우 CPU가 커널모드에서 수행중이라고 얘기한다. 반대로 사용자 프로그램을 수행하고 있다면 수행자 모드라고 알려주게 된다.

CPU가 수행하는 명령에는 일반 명령과 특권 명령이 있다. 일반 명령은 메모리에서 자료를 읽어와서 cpu에서 계산하고 결과를 메모리에 쓰는 일련의 명령들을 말한다. 반면 특권명령은 보안이 필요한 명령으로 입출력 장치, 타이머 등 각종 장치를 접근하는 명령이다. 컴퓨터 시스템에서는 이러한 특권 명령을 운영체제만이 수행할 수 있도록 제한다. 컴퓨터 시스템은 이러한 권하을 체크하기 위해 CPU내에 모드비트를 둔다.

사용자 프로그램이 실행되다 보면 일반 명령외에 파일입출력과같은 특권 명령이 필요하다. 이와 같은 경우에 사용자 프로그램은 스스로 특권 명령을 수행할 수 없으므로 운영체제에게 특권 명령의 대행을 요청한다. 이와 같은 서비스 요청을 시스템 콜이라고 생각한다. 시스템콜을 하게되면 운영체제내에 정의된 함수를 실행하게 된다.

프로그램이 아닌 주변 장치가 CPU에게 서비스를 요청할 때에도 시스템 콜과 비슷한 방식을 사용한다. CPU는 프로그램 카운터가 가리키는 메모리 위치의 명령만 계속 수행하고 있기 때문에 주변 장치의 상태를 지속적으로 파악할 수 없다. 따라서 주변장치들이 CPU의 도움이 필요한경우 인터럽트를 발생킨다. CPU는 매번 명령을 수행한직후 인터럽트 라인크하는데 이때 요청이 들어왔는지 체크를 한다. 인터럽트는 다양한 종류가 있기때문에 원인에 맞는 기능을 처리하기위해 인터럽트 처리 루틴으로 넘어가서 인터럽트를 처리하게 된다.

### 3. 프로그램의 실행
프로그램이 실행되고 있다는것은 컴퓨터 시스템차원에서 볼 때 크게 2가지 중요한 의미를 가진다. 첫째는 디스크에 존재하던 실행 파일이 메모리에 적재됨을 의미한다. 두 번째는 프로그램이 CPU를 할당받고 기계 명령을 수행하고 있다를 의미한다. 일반적인 컴퓨터의 시스템에서 CPU는 하나밖에없다. 그러므로 여러 프로그램이 짧은 시간단위로 CPU를 나누어 쓰고, 마치 이들 프로그램이 동시에 실행되는것처럼 보여 프로그램이 동시에 실행된다는 말을 보편적으로 사용하는것이다.

실행파일이 메모리에 올라갈때 한번에 모든 파일들이 메모리에 올라가는게 아니라 일부분만 메모리에 올라간다. 해당 프로그램의 나머지부분은 스왑영역에 나두고 필요할때 메인 메모리로 읽어와 쓰게 된다.

프로세스의 주소 공간은 코드, 데이터, 스택 등으로 구성된다. 각각의 프로그램마다 이러한 주소공간을 가지며, 각 프로그램마다 독자적으로 존재하는 이와 같은 주소 공간을 우리는 가상 메모리 또는 논리적 메모리라고 부른다. 이는 실제 물리적 메모리의 주소와 독립적으로 각 프로그램마다 독자적인 주소 공간을 가지기 때문에 지징하는 용어이다.

운영체제도 하나의 프로그램이므로 운영체제 코널 역시 코드, 데이터, 스택 영역으로 주소공간이 구성된다. 운영체제의 기능은 하드웨어와 사용자프로그램의 중간 위치에서 둘의 인터페이스 역할을 한다. 운영체제는 중간에서 CPU와 메모리등의 자원을 관리하기 위한부분과 시스템콜 및 인터럽럽트 처리하기위한 코드 부분을 포함한다.

#### 운영체제의 주소 공간
**커널의 코드 영역**
커널의 코드 영역은 CPU, 메모리등의 자원을 관리하기 부분과 사용자에게 편리한 인터페이스를 제공하기 위한 코드 부분이 주를 이루고 있다. 이밖에도 커널의 코드는 시스템 콜 및 인터럽트, 자원관리를 위한 코드 부분이 있다.

**커널의 데이터 영역**
각종 자원을 관리하기 위한 자료구조가 저장된다. CPU나 메모리와 같은 하드웨어 자원을 관리하기 위한 자료구조 뿐만 아니라 현재 수행중인 프로그램을 관리한 자료구조 커널의 데이터 영역에 유지된다. 현재 수행중인 프로그램을 프로세스라고 부르고, 커널의 데이터 영영죽에는 각 프로세스의 상태, CPU 사용정보, 메모리 사용정보 등을 유지하기 위한 PCB(프로세스 제어블록)두고 있다. 이와같이 커널 데이터 영역은 시스템내의 모든 자원을 관리하기위한 자료구조를 각각 가지고 있다.

**커널의 스택 영역**
커널의 스택영역은 일반 프로그램의 스택 영역과 마찬가지로 함수의 호출시의 복귀 주소를 저장하기 위한 용도로 사용된다. 하지만 커널의 스택은 일반 사용자 프로그램의 스택과 달리 현재 수행중인 프로세스마다 별도의 스택을 두어 관리한다. 이러한 이유는 당연하겠지만 프로세스의 주소와 운영체제의 주소가 다르기 때문이다. 하나의 프로세스에 의해 시스템콜이 일어나면 커널에 정의된 시스템콜을 호출하고 시스템콜 내부에서 다른 함수를 호출할경우 그 복귀 주소는 커널에 의해 실행되어 커널내의 주소가되어 사용자 프로세스(프로그램)의 스택과는 별도의 저장이 되어야만 하기때문이다.

### 4. 사용자 프로그램이 사용하는 함수
프로그램이 사용하는 함수는 크게 사용자 정의 함수와 라이브러리 함수, 커널 함수의 세가지로 구분할 수 있다. 사용자 정의 함수와 라이브러리 함수들은 사용자 프로그램이 실행될 때에 해당 프로세스의 주소 공간에 포함된다. 또한 함수 호출시에도 자신의 주소 공간에 있는 스택을 사용하게 된다.
반면 커널 함수는 운영체제의 커널 주소공간에 코드들이 정의 된다. 물론 호출된 주소들은 커널의 스택영역에 저장된다. 커널 함수의 종류에는 사용자 프로그램이 운영체제의 서비스를 요청하기 호출하는 시스템콜 함수와, 각종 하드웨어 및 소프트웨어가 CPU의 서비스를 요청하기 위해 발생시키는 인터럽트 처리 함수 가 있다.

### 5. 인터럽트
인터럽트는 하드웨어 인터럽트와 소프트웨어 인터럽트(트랩)로 나누어 볼 수 있으며, 일반적으로는 하드웨어 인터럽트를 의미한다. 즉, 하드웨어 컨트롤러가 CPU의 서비스를 요청하기위해 발생시키는 인터럽트가 일반적 의미이다. CPU는 프로그램 카운터가 가리키는 곳에 있는 명령을 수행하는 일밖에 하지 않기 때문에 현재 수행중인 프로세스로부터 CPU를 회수해 CPU가 다른일을 수행하도록 인터럽트라는 매커니즘이 필요하다.



#### 하드웨어 인터럽트
일반적으로는 하드웨어 인터럽트를 의미한다. 즉, 하드웨어 컨트롤러가 CPU의 서비스를 요청하기위해 발생시키는 인터럽트가 일반적 의미이다.


**타이머 인터럽트**
특정 프로세스가 CPU를 독점하는것을 막기위해 운영체제는 타이머 인터럽트를 사용한다. 타이머는 시간이되면 CPU에게 인터럽트를 발생시키는 하드웨어 장치이다.

#### 소프트웨어 인터럽트(trap)
트랩이란 소프트웨어가 발생시키는 인터럽트를 말한다. 트랩의 종류에는 예외 상황과 시스템콜의 두 종류가 
있다.



**예외 상황**

예외 상황은 프로그램이 허용되지 않은 연산을 수행하려고 할 때 자동적으로 발생하는것으로 운영체제는 예외상황이 발생했을 때 CPU의 제어권을 획득해 해당 상황에 대한 조치를 취하게 된다. 예외 상황의 예로는 0으로나누는 연산, 메모리할당을 넘어서는 데이터 할당등이 있다. 운영체제는 예외상황에 대한 처리 루틴을 인터럽트 처리루티관 마찬가지로 자신의 코드영역에 가지고 있다.

**시스템콜**
시스템콜은 사용자 프로세스가 운영체제의 서비스를 요청하기위해 함수를 호출하는것을 의미한다. 사용자 프로세스가 직접 특권 명령을 수행할 수 없으므로 사용자 프로세스가 특권 명령을 수행하려 할 때 시스템콜을 사용하게 된다. 시스템콜이나 예외상황은 무조건 운영체제의 의해 처리되어지는데 이과정에서 인터럽트라인이 셋팅되고 제어권이 CPU에게 넘어 가게 된다. 단지 인터럽트를 발생시키는 주체가 하드웨어가 아닌 소프트웨어인것이다. 이것을 소프트웨어 인터럽트또는 트랩이라 한다.


#### 인터럽트 벡터
인터럽트 벡터란 여러가지 인터럽트에 대한 해당 인터럽트 발생시 처리해야할 루틴의 주소정보를 가지고 있는 테이블을 의미한다.
#### 인터럽트 핸들러
인터럽트 핸들러는 실제 인터럽트를 처리하기 위한 루틴으로 서비스 루틴이라고도 한다. 이미 운영체제는 인터럽트가 발생시 실행되어야할 코드가 다 코딩되어있고 이것은 서비스 루틴에 저장되어 있다.


### 6. 시스템콜
운영체제 모드는 크게 2가지로 사용자 모드와 커널 모드가 있다. CPU가 사용자프로그램에 의해 선점되어져있을 때를 사용자 모드라고하는데 이 때 사용자 프로그램이 파일입출력 등 커널모드에 특권명령을 수행하기위해서는 운영체제에게 시스템콜을 호출하여 특권 명령 대행을 요청해야한다. 이때 발생하는것을 `시스템 콜`이라고한다. 다음은 디스크의 파일 입출력이 이루어지는 과정을 통해 시스템 콜 사용의 예를 살펴보겠다.

1. 사용자 프로그램이 CPU를 보유하고 있던중 디스크에서 파일을 읽어와야할 경우 시스템콜로 커널의 함수를 호출하게 된다.
2. 이때 사용자 프로그램은 CPU의 제어권을 운영체제에 이양하게되는데 이는 인터럽트 라인을 세팅하는 명령으로 이루어진다.
3. 인터럽트 라인이 세팅되면 CPU는 다음 명령을 수행하기전에 인터럽트가 발생했는지 점검하게되며, 이과정에서 인터럽트가 발생한것을 인지하고 현재 수행중인 사용자 프로그램을 잠시 멈추고 CPU의 제어권을 운영체제에게 이양시키게 된다.
4. 운영체제는 설정된 인터럽트 라인에 의해 발생한 인터럽트가 입출력을 요청하는 인터럽트이을 인지하게 된다.
5. 다음 해당 서비스 루틴으로 이동해 입출력을 수행하게된다. (이 과정에서 CPU는 디스크 컨트롤러에게 파일을 읽어오라는 명령을 하게 된다.)
6. 디스크 컨트롤러가 디스크에서 데이터를 읽어오는 오랜작업이 걸리기 때문에 이때 CPU제어권은 다른 프로세스에게 넘어간다(입출력을 했던 process는 해당 파일 입출력이 일어날때까지 봉쇄상태에빠지기때문에 해당 프로세스에게는 CPU가 이양되지 않는다.)
7. 입출력 작업이 완료되면 디스크컨트롤러는 인터럽트를 발생시켜 CPU에게 알린다.
8. CPU는 커널모드로 권한이 넘어가고 해당 인터럽트 처리루틴으로가서 디스크 로컬버퍼에서 데이터를 읽어와 메모리에 복사하고 파일 입출력을 요청해던 프로세스에게 다시 CPU를 획득할 수 있는 권한을 준다.
9. 해당 프로세스는 CPU의 기다리는 큐에 삽입되고 CPU의 제어권은 다시 인터럽트를 당했던 프로세스에게 넘어가 하던작업을 계속 수행하게 된다.

지금까지 살펴본내용을 통해 어떤 프로그램이 CPU를 할당받고 명령을 수행하다가 중간에 CPU를 선점당하는 경우는 크게 타이머인터럽트와 입출력 인터럽트가 있었다.

### 7. 프로세스의 상태
프로세스의 상태는 실행, 준비, 봉쇄의 세가지로 크게 나누어볼 수 있다.

실행 상태 : CPU할당받고 기계어 명령을 수행하고 있는 프로세스의 상태를 가리킨다.
준비 상태 :CPU만 할당 받으면 당장 명령을 수행할 수 있지만 CPU가 하나밖에 없어 현재 CPU를 할당받지 못한 상태를 말한다.
봉쇄 상태 : CPU를 할당받더라도 명령어 수행할 수 없는 프로세스의 상태를 말한다.(ex:파일입출력)

#### 준비 큐(ready queue)
운영체제는 준비상태에 있는 프로세스들을 차례대로 실행시키기위해 `준비 큐`를 두고 프로세스에게 CPU를 할당한다. 이렇게 준비큐에 있는 프로세스들을 실행시키는 경우는 아래와같은 상황이 발생할 떄 실행 시킨다.
* 실행 상태에 있던 프로세스가 입출력 요청등으로 봉쇄상태가 되는 경우 첫번째준비큐에 있던 프로세스에게 CPU를 할당해준다.
* 타이머 인터럽트가 발생할 경우 준비큐에 있던 프로세스에게 CPU를 할당해준다.

#### 자원별 큐
CPU를 기다리는 프로세스를 줄세우는 준비큐외에도 운영체제는 특정자원을 기다리는 프로세들을 줄세우기 위해 자원별로 큐를 두고 있다.
* 디스크 입출력 큐
* 키보드 입출력 큐
* 등등

자원을 사용하기 위해 위와같이 큐에 줄 서있는 프로세스들의 입출력 작업을 수행하게 된다. 프로세스별 입출력 작업이 완료되면 디스크 컨트롤러가 CPU에게 인터럽트를 발생시키게 되고, 그러면 인터럽트 처리 루틴에 의해 디스크 입출력이 완료된 프로세스는 입출력 큐에서 빠져나와 CPU를 기다리는 준비 큐에 줄서게 된다. 
![장치별IO큐](/assets/장치별IO큐.png) 
<center>
-자원 별 큐-
</center>

위에서 언급된 큐들은 하드웨어 자원을 기다리는 프로세스들을 줄제우기 위한것이 었다. **위 그림과 같이 큐를 사용하는 이유는 동시에 2개의 프로세스가 공유 데이터에 대한 접근 막기 위해서이다. 어떠한 프로세스가 하나의 입출력 장비를 사용하고 있는데 도중에 다른 프로세스가 같은 데이터를 접근하고 조작한다면 데이터에 대한 일관성이 훼손될것이다.**

#### 장치별 큐 관리
![커널의장치별큐관리](/assets/커널의장치별큐관리.png)
<center>
-프로세스의 상태 변화 큐를 관리하는 커널 주소 공간 구조-
</center>
위 그림은 프로세스의 상태 변화큐를 관리하는 커널의 주소 공간 구조이다. 각 프로세스들이 CPU를 기다리지, 입출력을 기다리는지등의 정보를 커널이 총체적으로 관리하고 있다. 


### 8. 프로세스의 두가지 실행 상태
운영체제위에서 프로그램을 실행시키면 크게 2가지 모드에서 실행되는데 이것을 각각 사용자모드와 커널모드 라고 한다. 

#### 사용자 모드
사용자프로그램이 정의한 함수나 라이브러리 함수를 호출하는것을 말한다.
#### 커널 모드
입출력 시스템콜등을 통해 운영체제 커널의 함수도 호출하는 것을 말한다.

이때 한가지 주의할점은 비록 시스템콜이 실행되는것이 프로세스 A의 코드가 아니라 운영체제 커널의 코드이지만 시스템 콜이 수행되는 동안 커널 실행상태에 있다고 하지 않고 프로세스 A가 실행 상태에 있다고 말한다. 이러한 이유는 프로세스 A가 실행하고자하는 코드를 커널이 대신 수행해줄 뿐이기 때문이다.

한편 CPU의 제어권이 사용자 모드에서 커널모드로 변경되는 경우는 크게 **시스템콜**과 **하드웨어 인터럽트**가 발생한경우가 있을 수 있다.


참조
* [운영체제와 정보기술의 원리](http://www.yes24.com/24/goods/2824944)
