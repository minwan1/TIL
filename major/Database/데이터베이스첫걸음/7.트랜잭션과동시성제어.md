# 트랜잭션과 동시성 제어
## 트랜잭션을 다룰 수 있는 테이블을 작성해보자
데이터베이스를 사용하는 실제 시스템이나 애플리케이션에서는 단일 쿼리만으로 조작하는 일은 거의없고 복수의 쿼리를 연속적으로 사용해 일관성 있는 형태의 한 단위로 취급해야합니다. 이런 한 덩어리의 쿼리 처리 단위를 '트랜잭션'이라고 합니다. 

## 트랜잭션이란
### 트랜잭션
일반적인 DBMS에서의 애플리케이션 로직을 구성할 때 사용하는 트랜잭션이나 잠금 구조를 공부합니다. 데이터베이스에서 갱신은 단일 쿼리만으로 구성된것이 아니고 복수 쿼리를 연속적으로 수행하는 경우가 대부분입니다. 또한, 갱신전의 데이터로 SELECT를 사용할 대 이를 포함해 복수 쿼리를 일관된 형태의 한덩어로 다뤄야합니다. **트랜잭션**이란 이런 복수 쿼리를 한단위로 묶은 것입니다.

트랜잭션은 다음 4가지 특성을 가진다
* 원자성(Automicity)
* 일관성(Consistency)
* 고립성(Isolation) // 동시에 데이터를 고쳐지는것을 막는것
* 지속성(Durability)

**원장성**
데이터의 변경(CUD)를 수반하는 일려의 데이터 조작이 전부 성공할지 전부 샐패할지를 보증하는 구조입니다.

**일관성**
데이터베이스에는 데이터베이스 오브젝트에 대해 각종 정합성 제약을 추가할 수 있습니다. 이는 일련의 데이터 조작 전후에 그상태를 유지하는것을 보증하는 즉 '일관성'을 유지하기 위한 구조입니다. 예를들면 시스템에 사용자를 등록할 때 사용자를 임의로 식별하기 위해 일련의 번호를 사용자에게 발급합니다. 이때 이번호는 유니크제약을 성정하면 중복된 번호를 저장할 수 없습니다.

**고립성**
일련의 데이터 조작을 복수 사용자가 동시에 실행되도 **'각각의 처리가 모순 없이 실행되는것을 보증한다'** 는 것입니다. 

예를들어 부산의 호텔에 남은 싱글룸수가 10개였을 때 실제 숙박을 예약하는 프로그램을 하면 다음과 같습니다.
1. 현재 빈 싱금룸의 수를 확인한다(SLELECT)
2. 빈 싱글룸 수에서 방하나를 빼고 결과를 빈 싱글룸 수로 되돌려 쓴다.(UPDATE)

이것을 사용자 A와 사용자 B가 동시에 수행하면 어떻게 될까. 사용자 2명이 방을 예약하지만 실제로는 아마 방은 1개만 줄어들게 될겁니다. 이런 사태를 막기위해 데이터베이스 테이블에대해 **잠금**을 걸어 후속처리를 블록하는 방법이 있습니다. 잠금 단위는 **테이블전체, 블록, 행** 등이 있는데, MySQL에서는 트랜잭션 처리를 할 때 주로 행단위의 잠금 기능을 이용합니다. 

결국 앞에서 말한 **고립성**을 설명한 각각의 트랜잭션 처리를 순서대로 실행되는것을 보증하는 것을 의미한다고 생각하시면 됩니다. 이것을 DBMS에서 격리수준으로 구현하고 제공하는것이 **직렬화 가능**이라는 사양입니다. 하지만 직렬화 가능의 고립성에서는 항상 동시에 동작하는 트랜잭션이 1개의 이미지가 되어 성능명에서 실용적이지 않습니다. 이때문에 직렬화 가능으로부터 격리 수준을 완화해 직렬화 가능이외에 아래와같이 4개의 단계를 정의했습니다.

1. 커밋되지 않은 읽기(Read Uncommitted, 리드 언커밋티드)
2. 커밋된 읽기(Read Committed, 리드 커밋티드)
3. 반복 읽기(Repeatable read,리피터블 리드)
4. 직렬화 가능(Serializable, 시리얼라이저블)

이중 4의 직렬화가능이 가장 엄격하며 숫자가 작아질수록 완환되어지는 격리 수준입니다. 그러나 격리수준이 완화되면서 **직렬화가능**에서 발생하지 않았던 현상이 생깁니다. 이현상은 아래와같이 3가지입니다.

|현상|개요|
|-|-|
|더티 읽기 | 어떤 트랜잭션이 커밋되기 전에 트랜잭션에서 데이터를 읽는 현상이다. 동시에 하나의 데이터를 변경하려고했을 때 발생하여 데이터가 더럽혀지는 현상으로써 더티읽기라고 한다. 사용자 A가 빈 싱글룸 수가 '10'인 레코드를 '9'로 변경한 경우 커밋전이라 하더라도 사용자 B가 SELECT 한 결과는 '9'가된다. 확정전의 '더럽혀진(Dirty)' 데이터를 읽는(read)것에서 붙여진 이름이다. |
|애매한 읽기 | 어떤 트랜잭션이 이전에 읽어 들인 데이터를 다시 읽어 들일 때 2회 이후의 결과가 1회 때와 다른 현상이다. 예를들면 최초에 사용자 A가 '빈 싱글룸 수 '10'을 읽고 그 후 사용자 B가 값을 '9'로 변경해 커밋 했다고 하자. 계속해서 사용자 A가 SELECT 를 다시 실행하면 최초에 SLECT 햇떤 '10'이 아닌 변경후의 '9'를 읽어 들이게 된다. 사용자 A가 최초에 읽은 값은 '10'이 2회 이후의 SELECT 에서 보증되지 못하고 애매하게 되는것에서 붙여진 이름이다. DBMS 메뉴얼에서는 '반복 불가능한 읽'로 소개하는 경우가 있다.|
|팬텀읽기(Phantom Read | 어떤 트랜잭션을 읽을 때 선택할 수 있는 데이터가 나타나거나 사라지는 현상이다. 최초에 사용자가 A 범위 검색(예를 들면, 빙 싱글룸 수가 10이상의 호텔)을 수행 후 3행을 읽었다고 가정하자. 계속해서 사용자 B가 막 그 범위에 들어가는 데이터 1행을 INSERT하고 커밋도 실행했다. 계속해서 사용자 A가 다시 같은 SELECT문을 실행하면 최초에 SELCT해서 얻었던 3행이 아닌 4행이 선택된다. 이처럼 나타나거나 사라지는 (DELETE나 UPDATE로 사라진다.) 데이터가 '유령'(Phantom)과 닮아서 붙여진 이름이다. |

|격리 수준|더티 읽기|애매한 읽기| 팬텀 읽기|
|-|-|-|-|
|커밋되지 않은 읽기 | O |O |O |
|컷미된 읽기 | X| O|O|
|반복 읽기 | X|X |O|
|직렬화 기능 | X|X |X|


**지속성**
지속성은 일련의 데이터조작을 완료(commit)하고 완료 통지를 사용자가 받는 시점에서 그조작이 영구적이되어 그결과를 잃지 않는것을 나타냅니다. 이것은 시스템이 정상일 때 만이 아니라 데이터베이스나 운영체제의 이상종료, 즉 시스템 장애도 견딜수 있다는 뜻입니다. 






