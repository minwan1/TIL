## 인터페이스와 클래스
객체는 객체가 제공하는 기능으로 정의된다고 했는데, 보통 객체가 제공하는 기능을 오퍼레이션이라고 부른다. 즉 객체는 오퍼레이션으로 정의가 된다. 객체가 제공하는 기능을 사용한다는것은 결국 오퍼레이션을 사용한다는말이다.

예를들어 소리크기 증가 기능을 제공하는 오퍼레이션이 있으면 우리는 이 오퍼레이션에 사용버을 알아야한다. 이 오퍼레이션에 사용법은 다음과같이 구성된다.
* 기능 식별 이름
* 파라미터 및 파라미터타입
* 기능 실행 결과값

객체가 제공하는 모든 오퍼레이션 집합을 객체의 인터페이스라고 부르며, 서로다른 `인터페이스`를 구분할 때 사용되는 명칭이 바로 `타입`이다.


## 메시지

객체지향은 기능을 제공하는 여러 객체들이 모여서 완성된 어플리케이션을 구성하게 된다. 아래와 같이 파일에서 데이터를 읽어오는 객체가 있고, 데이터를 암호화 해주는 객체가 있고, 파일에 데이터를 쓰는 개체가 있다고하자. 

![](https://i.imgur.com/IsuI5Aq.jpg)

위의 그림에서 첫번째 오퍼레이션을 찾으면 read()함수이다.
* 오퍼레이션 이름 : read
* 파라미터 : 없음
* 리턴타입 : byte배열

이때 암호화 처리객체가 read()함수를 호출하는것을 '메시지'라고표현한다.

## 객체의 책임과 크기
객체는 객체가 제공하는 기능으로 정의 된다고 했다. 이는 다시 말하면 객체마다 자신만의 책임을 가진다느 의미이다. 위의 암호화 처리과정을 객체 책임별로나누면 아래와같을 수 있다.

![](https://i.imgur.com/5SmKwLA.jpg)

한객체가 갖는 책임을 정의한것이 바로 타입/인터페이스라고 한다. 여기에서 책임을 결정짓는것이 바로 객체지향 설계의 출발이다.

객체지향 설계를 하기위해서는 필요한 기능을 목록을 정리해야한다. 다음은 위의 그림에서 처리하는기능의 과정을 정리한것이다
1. 파일의 byte 데이터를 제공한다.
2. 파일에 byte 데이터를 쓴다.
3. byte 데이터를 암호화햇 새로운 byte데이터를 생성한다.
4. 전체 흐름을 제어한다.

### 객체의 책임은 작을수록 좋다
객체지향적으로 프로그래밍을 할 때, 가장어려우면서 가장 중요한것이 바로 객체마다 책임을 할당하는과정이다. 상황에 따라 책임과 가져야할 기능의 종류와 개수가 달라지기 때문이다. 객체가 얼마나 많은 기능을 가져야하는가는 확실한 규칙은없다. 단지 객체가 갖는 책임은 작을수록 좋다. 

### 객체에 책임이 많아지면 프로시저 프로그래밍이 되어진다.
왜 책임을 작게 만들면 좋은지는 아래의 그림을 보면알 수 있다.
![](https://i.imgur.com/Gfr0XFm.jpg)
위의 그림처럼 한객체에 많은 책임을 할당하게 되면 일단 재활용하기가 힘들어 지면서 절차지향 프로그래밍으로 변한다. 유저들은 암호화 기능이 아닌 파일읽기 기능만 필요하게 될 수있는데 위에 그림처럼 한곳에 모든 기능들이 다모이게되면 또 파일읽기 기능을 만들고 있어야할지 모른다. 뿐만아니라 이렇게되면 절차지향의 가장 큰 단점인 기능 변경의 어려움문제를 가지게된다. 기능을 하나 변경하기위해서는 객체 전방위적으로 변경이 필요하게 되어진다. 

객체의 크기와 관련있는 원칙이 있는데 그원칙은 바로 **단일책임원칙** 이다. 이름에서 알듯이 객체는 하나의 책임만을 가져야한다. 이 원칙에따라서 위의 예를 단일책임원칙의 구조로 변경하면 아래와같은 구조가 되어질 수 있다.

![](https://i.imgur.com/FppG0X7.jpg)

단일책임원칙을 따르다 보면 자연스럽게 기능의 세부내용이 변경될때 변경해야할부분에 집중할 수 있다.

>객체의 책임을 갖는다는것을 객체가 역할을 수행한다는 것을 의미한다. 객체지향서적에서 글을 읽을 때 '객체의 역할'이란 단어가 나오면 이것은 '객체의 책임'과 동일한 의미임을 기억하자. 

## 의존
객체지향적으로프로그램을 구현하다보면 , 다른 객체가 제공하는 기능을 이용해서 자신의 기능을 완성하는 객체가 출현하게된다. 예를들어 위의 흐름제어 객체는 'byte암호화', '파일읽기', '파일쓰기' 객체를 이용해서 **파일 데이터 암호화 프로그램의 실행 흐름** 기능을 완성했다.

이렇게 한 객체가 다른 객체를 생성하거나 다른 객체의 메소드를 호출할 때 이를 그객체에 '의존'한다고한다.

## 캡슐화

객체지향의 장점은 한곳의 구현 변경이 다른곳에 변경을 가하지 않도록 해준다는데 있다. 객체지향은 기본적으로 캡슐화를 통해 한곳의 변화가 다른곳에 미치는 영향을 최소화한다. 

**캡슐화**
캡슐화는 객체가 내부적으로 기능을 어떻게 구현하는지를 감추는것이다. 이를 통해 내부적 변경의 유연함을 주는 기법이다. 
### 캡슐화를 사용하지 않은 코드
캡슐화를 사용하지않으면 어떠한 단점들이 있는지 봐보자. 먼저 회원 서비스의 만료날짜 여부를 보여주는게 있다고 해보자. 그럼 다음과같은 코드가 구성되어질 수 있다.

```java
public class Member{
    private Date expiryDate;
    private boolean male;
    
    public Date getExpiryDate(){
        return expiryDate();
    }
    public boolean isMale(){
        return male;
    }
}
```
만료 여부를 체크하는 소스
```java
if(member.getExpiryDate() != null && member.getExpiryDate().getDate() < System.currentTimeMillis()){
    //만료되었을때처리
}
```
Member의 서비스가 만료되었는지 확인하기위해서는 위와 같은 코드가 있다고 해보자. 그런데 요구사항의 변경으로 인해 여성회원들은 만료기간이 30일 지났어도 서비스를 사용할 수 있다고 해보자. 만료 여부기준이 변경되었음으로 소스를 수정해야한다. 이렇게되면 위와같은 모든 소스를 찾아서 수정해야한다. 만약 위와같이 회원 서비스 만료여부를 체크하는 부분이 많다면 수정을 못한부분이 있다면 버그로 이어진다.

문제는 어떻게 버그없이 수정했다고해도 다음번에 또 요구사항이 변경된다면 다시 한번 똑같은 노가다 + 버그생길확률을 가지게된다. 그렇다면 왜이런 이유가 발생했을까. 자바로 절차지향프로그래밍을 했기 때문이다. 아래의 그림처럼 데이터를 직접적으로 사용하는 코드는 데이터의 변화에 직접적인 영향을 받기 때문에, 데이터를 기반으로 로직을 짠 모든 소스들은 다 변경해줘야한다.

![](https://i.imgur.com/JmyYycx.jpg)

**캡슐화가 아닌 객체의 직접 데이터 호출의 문제점**
이렇듯 객체의 데이터를 직접적으로 사용해서 비지니스로직을 사용하게되면 해당 비지니스로직에 정책변화는 전방위에 작성되어있는 비지니스로직의 변경을 의미하게 된다.

### 캡슐화 된 기능의 구현
이제 절차지향적인 접근이 아닌 객체지향적으로 코드를 재구성해보자. 캡슐화는 기능이 내부적으로 어떻게 구현되는 숨기는것을 의미한다고 했다. 그럼 숨긴다는것이 무엇인지 코드를 통해 직접 확인해보자.

```java
public class Member {
    //다른 데이터
    private Date expiryDate;
    private boolean male;
    private boolean isExpired(){
        return expiryDate != null && expiryDate.getDate() < System.currentTimeMillis()
        
    }
}
```

사실 요구사항을 다시보면 중요한것은 해당유저가 만료 여부였다. Member클래스를 사용하는 클래스들은 member가 어떻게 만료되는지 알필요가없다. 그냥 '이 회원 서비스 만료되었어 ??' 이게중요하다. isExpired라는 함수를 통해 캡슐화를 하고 내부 변경의 유연함을 가져가게되었다. 이게 추가적으로 요구사항이 변경된다고해도 해당 메소드만 변경하게되면 된다. 이렇듯 캡슐화를 통해 변경의 여파를 최소하 하게 했다.

### 캡슐화를 위한 두개의 규칙
앞서 예에서 보듯이 기능 구현을 캡슐화하는것은 어렵지 않다. 하지만 객체지향을 처음하는 사람들은 그동안 몸에밴 절차지향 방식 승괍때문에 무심결에 데이터 중심적인 코드를 만들기 쉽다. 이러한 습관을 고치는데 두가지법칙이 있다.

* Tell. Don`t ask
* 데미테르이 법칙

#### Tell. Don`t ask
위의 타이틀처럼 묻지말고 객체한테 시키라는 뜻이다. 위에서 본예제처럼 실제 데이터를 꺼내서 뭔가 물어보고 비지니스로직을 작성하려하지말고 isExpired함수로 , 해당 객체한테 말해서 명령하자. 코드로보면 아래와같을 수 있다.
```
if(member.isExpired()){
    //만료에 따른 후속처리
}
``` 
#### 데미테르이 법칙

* 메소드에서 생성한 객체의 메소드만 호출
* 파라미터로 받은 객체의 메소드만 호출
* 필드로 참조한느 객체의 메소드만 호출

```java
public void processSome(Member member){
    if(member.getDate().getTime() < ...){ 데이테르의 법칙 위반
        
    }
}
```
이때 위 코드는 데미테르 법칙을 어긴것이다. 데미테르의 법칙에 따르면 파라미터로 전달받은 객체의 메서드만 호출하라고했는데 위의 경우 해당 객체의 메소드호출후 다시한번 get메소드를 호출하고있다. 이것을 법칙에 맞게하면 위코드를 Member 객체에대한 한번의 메소드 호출로 변경하면된다. 이는 결국 데이터중심이 아닌 기능 중심으로 코드를 작성하도록 유도한다.

#### 신문 배달부와 지갑
다음은 데미테르의 법칙을 설명할 때 사용되는 유명한예이다.

신문 배달부가 고객에게 요금을 받아가는 상황을 코드로 작성해보자. 다음은 고객과 지갑을 클래스화한것이다.
```java
public class Customer{
    private Wallet wallet;
    private Wallet wallet;
    public WALLET getWallet(){
        return wallet;
    }
    
}

public class Wallet{
    private int money;
    public int getTotalMoney(){
        return money;
    }
    public void substractMoney(int debit){
        money -= debit;
    }
}
```
신문 배달부 클래스는 다음과 같을것이다.

```java
//Paperboy 클래스의 코드
int payment = 10000;
Wallet wallet = cusotmoer.getWallet();
if(wallet.getTotalMoney() >= payment){
    wallet.substractMoney(payment);
}else{
    //다음에 요금받으러옴
}
```
개념적으로 위코드는 신문 배달부가 아래와같은 방법으로 요금을 받아간다.

* 고객님 지갑 주세요 : customer.getWallet();
* 지갑에 돈이 있는지 확인합니다 : wallet.getTotalMoney() >= payment
* 지갑에서 돈을 빼가겠습니다 : wallet.substractMoney(payment);

어떤 신문 배달부도 고객의 돈을 다받아서 계산이 가능한지 확인하고서야 돈을 가져가지않는다. 그리고 지갑에 돈이 없고 주머니에 돈이 있을 수 도 있다. 이렇게되면 비지니스로직을 다 변경해야한다.

좀 더 현실적으로 코드를 변경하면 신문 배달부가 직접 돈의 계산여부를 계산하는게 아닌 고객이 돈을 계산하는방법이 되어질 수 있다.

```java
public class Customer{
    private Wallet wallet;
    
    public int getPayment(int payment){
        if(wallet == null) throw new NotEnoghMoneyException();
        if(wallet.getTotalMoney() >= payment){
            wallet.substractMoney(payment);
            return payment
        }
        throw new NotEnoughMoneyException();
    }
}
```

그럼 신문 배달부 소스는 다음과 같을 수 있다.


```java
int payment = 10000;

try{
    int paidAmont = customer.getPayment(payment);
}catch(NotEnoughMoenyException ex){
    //다음 요금받으로 오는 처리
}
```

이제 더이상 신문 배달부는 고객의 돈의 여부를 확인하지 않아도된다. 만약 고객이 신문말고 책을 산다고해도 코드를 재활용할 수 있게 되었다. 

그리고 이전 코드는 데미테르의 법칙을 어기고 있었다. 바로 전달받은 customer 클래스안에 wallet객체를 꺼내서 돈을 꺼냈었다. 만약 지갑이 null이거나 지갑이 아닌 주머니에서 돈을 꺼낸다고하면 전방위적으로 코드를 변경해야하는 코드였었다. 하지만 변경된 코드는 자연스럽게 데미테르 법칙을 지키기위해 Customer객체의 getPayment()메소드를 호출하게 되었다.

데미테르의 법칙을 지키지 않으면 보이는 전형적인 증상이 다음 둘이다.

* 연속된 get메소드 호출
* 임시 변수의 get호출이 많음

```java
value = someObject.getA().getB().getValue();
```

```
A a = someObject.getA();
B b = a.getB();
value = b.getValue();
```
위 두가지 케이스가 보이는 경우 데미테르의 법칙을 어기고 있을 가망성이 크다. 이는 캡슐화를 악화시켜 코드변경을 어렵게만드는 원인이 될 수 있다. 

## 객체지향 설계 과정

지금까지 객체의 정의, 책임, 의존, 캡슐화에 대해서 알아봤다. 이들 내용을 종합적으로 정리해보면 객체지향 설계란 다음의 작업을 반복한다고 볼 수 있다.

1. 제공해야할 기능을 찾고 또는 세분화하고, 그 기능을 알맞은 객체에 할당한다.
    1. 기능을 구현하는데 필요한 데이터를 객체에 추가한다. 객체에 데이터를 먼저 추가하고 그 데이터를 이용한 기능을 넣을 수 도 있다.
    2. 기능은 최대한 캡슐화해서 구현한다.
2. 객체간에 어떻게 메시지를 주고 받을 지 결정한다.
3. 과정1과 과정2를 개발하는 동안 지속적으로 반복한다.


앞서 파일 데이터의 암호화 과정에서 뽑았던 기능을 봐보자.
* 파일에서 데이터 읽기
* 데이터를 암호화 하기
* 파일에 데이터 쓰기


객체의 크기는 한번에 완성되보다는 구현을 진행하는 과정에서 점진적으로 명확해진다.
![](https://i.imgur.com/IsuI5Aq.jpg)
위의 그림도 암호화 처리 객체는 실제 두 기능을 함께 제공하고 있다.
* 흐름 제어(데이터 읽고, 암호화하고, 데이터 쓰고)
* 데이터 암호화

처음에는 이것이 불명확한 경우가 많다. 구현을 진행하는 과정에서 암호화 알고리즘을 변경해야할 때, 데이터 암호화 기능과 흐름 제어가 한객체 섞여 있다는것을 알게 될 수 도 있ㄷ. 또는 암호화 기능만 테스트하고싶은데, 흐름 제어 기능과 암호화 기능이 섞여 있어서 암호화 기능만 테스트하는것이 힘들 때 알게 될 수 도 있다.

구현과정중에 이렇게 한 클래스에 여러 책임이 섞여 있다는것을알게되면 아래의 그림처럼 클래스를 분리해 책임을 분리하게된다.
![](https://i.imgur.com/FppG0X7.jpg)
객체 설계는 한번에 완성되지 않으며, 개발이 진행되면서 설계도 함께 변경된다는것을 의미한다. 이는 최초에 설계가 완벽하지 않으며, 개발이 진행되면서 설계도 함께 변경된다는것을 의미한다. 따라서 설계를 할 때에는 변경되는 부분을 고려한 유연한 구조를 갖도록 해야한다.


# 다형성과 추상타입
