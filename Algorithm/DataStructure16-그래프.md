## 그래프
요즘 인터넷에서도 버스와 지하철의 노선들 확인할 수 있다. 뿐 만 아니라 출발지와 목적지를 정하면, 그에 맞는 최적의 경로를 알 수도 있다. 이러한 프로그램의 구현에 사용되는것이 바로 그래프 알고리즘이다.
![](https://i.imgur.com/ssLAmjg.png)
위 그림에서 간선은 다리를 의미하고, 정점은 다리가 연결하는 강으로 구분되는 땅으로 의미한다. 여기에서 정점 별로 연결된 간선의 수가 모두 짝수가 아니기 때문에 쾨니히스베르크의 다리에서는 처음 출발한 장소로 돌아오지 못하는것이다. 모두 짝수개의 간선이 있어야 되돌아 올 수 있다.

## 그래프의 이해와 종류
앞서 설명한 정점과 간선을 이용한것을 그래프라고한다

**무방향 그래프**
연결과예에 있어서 방향성이 없는 그래프를 가리켜 '무방향 그래프'라 한다.

**방향 그래프,다이그래프**
간선에 방향 정보가 포함된 그래프를 가리켜 방향그래프, 다이그래프라 한다.

**완전 그래프**
![](https://i.imgur.com/5ZxqUcH.png)
무방향그래프,방향그래프는 간선의 연결 형태에 따라서 '완전 그래프'로 구분이 된다. 다음 그림에서 보이는것이 완전 그래프이다.

**가중치그래프와 부분 그래프**
다음 아그래 그림처럼 가중치를 정보를 두어서 그래프를 구성하는것을 가중치 그래프라한다.
![](https://i.imgur.com/Ah77PBC.png)
그리고 부분집한과 유사한 개념으로 부분 그래프라는것이 있다. 부분 집합이 원집합의 일부 원소로 이루어진 집합인것처럼 부분 그래프는 원래 그래프의 일부정점 및 간선으로 이뤄진 그래프를 뜻한다. 위에 3번째,4번째 그림이 이에 해당한다.


**그래프의 집합 표현**
그래프는 정점과 간선의 집합이다. 따라서 집합의 표기법을 이용해서 표현할 수 있다. 먼저 다음 그림의 무방향 그래프를 집합의 표기법으로 표현해 보겠다.
![](https://i.imgur.com/rzEetXu.png)
먼저 왼쪽위의 무방향 그래프를 보자. 다음과 같이 정점의 집합과 간선의 집합으로 나누어서 표현을 한다.

* 그래프 G의 정점 집합 V(G)로 표시함
* 그래프 G의 간선 집합 E(G)로 표시함

그리고 무방향 그래프에서 정점 A와 정점 B를 연결하는 간선을 (A,B)로 표시한다. 따라서 위 그림의 그래프를 집합으로 표현하면 각각 다음과 같다.

V(G1) = {A, B, C, D}
V(G2) = {A, B, C, D}

E(G1) = {(A,B), (A,C), (A,D), (B,C), (C,D)};
E(G2) = {(A,C), (A,D), (B,C)};
위에 설명한것은 무방향 그래프이므로 (A,B), (B,A)는 같은 간선을 나타낸다. 그럼 왼쪽그림 옆에 그림을 대상으로 방향 그래프의 집합 표현법을 설명해보겠다.

무방향 그래프의 집합 표현과의 유일한 차이점은 방향성이 있는 간선의 표시법에 있다. 위그림을 보면 두 그래프 모두 정점 A가 정점 C를 가리키는데 이러한 간선은 다음과 같이 표현한다.
 정점 A가 정점 C를 가리키는 간선 <A,C>

따라서 위 그림의 두 그래프는 각각 다음과 같이 ㅛ현된다.

V(G3) = {A, B, C, D}    E(G3) = {<A, B>, <A, C>, <D, A>}
V(G4) = {A, B, C, D}    E(G4) = {<A, C}, <B, C>, <D, A>}


**그래프의 ADT**
그래프를 생성 및 초기화 할때 간선의 방향성 여부를 선택할 수 있고, 가중치의 부여 여부도 선택할 수 있다. 뿐만 아니라, 이후에는 얼마든지 그리고 언제든지 정점과 간선을 삽입하고 삭제할 수 있다는 최고의 그래프 구성이다. 하지만 다음 우리가 주제해야할 부분은 그래프의 구성을 위한 ADT는 필요한 만큼 제한적으로 정의할것이다. 구성이후의 주제에 더관심을 두어야하기 때문이다. 따라서 다음과같은 수준으로 ADT를 정의할것이다.

1. void GraphInit(UALGraph * pg, int nv);
- 그래프의 초기화를 진행한다.
- 두 번째 인자로 정점의 수를 전달한다.

2. void GraphDestroy(UALGraph * pg);
- 그래프 초기화 과정에서 할당한 리소스를 반환한다.

3. void AddEdge(UALGraph * pg, int fromV, int toV);
- 매개변수 fromV와 toV로 전달된 정점을 연결하는 간선을 그래프에 추가한다.

4. void ShowGraphEdgeInfo(UALGraph * pg);
- 그래프의 간선정보를 출력한다.

위에 정점의수는 정하게하고, 간선은 추가는되데 삭제는 안되게 정의를 했다. 실제로 응용 프로그램을 개발하는 경우에도 이정도의 수준에서 그래프를 구성하는 경우가 흔한다.

다음은 헤더에 아래와같이 열거형 상수를 정의할 것이다.
enum {A,B,C,D,E,F,G,H,I,J}; //정점의 이름
위에 상수는 GraphInit함수의 두 번째 인자로 5가 전달되면 정점 A,B,C,D,E로 이뤄진 그래프가 형성되게 할 것이다. 그리고 이상수들이 AddEdge함수의 인자로 전달될 수 있게 할 것이다. 물론 실제 프로그램의 개발에 활용한다면, 다음과 같이 의미 있는 이름을 부여해야 옳다.

enum{SEOUL, INCHEON, DAEGU, BUSAN, KWANGJU}; //의미 있는 정점의 이름

**그래프를 구현하는 두 가지 방법**
그래프를 구현하는 방법에도 배열을 이용하는 방법과 여녈리스트를 이ㅛㅇ하는 방법으로 나뉜다. 하지만 그래프에서는 이들 각각을 다음과 같이 표현한다.
* 인접 행렬 기반 그래프   정방 행렬을 활용[가로셀이가 같은 행렬을 의미]
* 인접 리스트 기반 그래프  연결 리스트를 활용

정방 행렬은 가로세로의 길이가 같은 행렬을 의미하는데, 이러한 행렬은 2차워 배열로 표현한다. 즉 위에서 말하는 정방 행렬은 2차원 배열을 뜻하는것이다.

![](https://i.imgur.com/pd6PD1P.png)

위그림에서 보이듯이 정점이 2개이면 가로세로의 길이가 4인 2차원 배열을 선언한다. 그리고 두정점이 연결되어 있으면 1로, 연결되어 있지 않으면 0으로 표시한다. 단, 간선의 방향성이 없기 때문에 하나의 간선에 대해서 두 개의 지점을 1로 표시해야한다. 예를 들어서[m][n]인 지점이 1로 표시되면, [n][m]인 지점도 1로 표시되어야 한다. 때문에 행렬은 대각선을 기준으로 대칭을 이룬다.

위에서 2번 째그림은 방향그래프의 인접행렬이다. 위 그림에서 보이듯이, A에서 B로 향하는 간선의 표시를 위해서 [0][1]인 위치를 1로 표시하였다. 그리고 이것이다 저눕이다. 때문에 무방향 그래프와 달리 대칭을 이루지 않는다.

이번에는 인접 리스트 기반의 그래프 표현방법을 살펴보자,
먼저 아래는 무바방향 그래프의 표현방법이다.
![](https://i.imgur.com/4sjayn7.png)
위에 첫번째 그림은 각각의 정점은 자신과 연결된 정점의 정보를 담기 위해서 하나의 연결리스트르를 갖는다. 그리고 각각의 정점에 연결된 간선의 정보는 가각의 연결리스트에 담아야한다.

위에서 두 번째 그림은 인접 리스트를 기반으의 방향 그래프의 표현 방법을 보인것이다. 방향 그래프에서는 각 정점별로 가리키는 정점의 정보만을 연결리스트에 담는다. 때문에 무방향 그래프에 비해서 추가된 노드의 수가 반으로 준다. 위의 2번쨰 그림 그래프에서 정점 A가 B,C,D를 가리킨다. 때문에 점점 A의 연결리스트에서만 노드의 정보가 추가되었다.

## 인접리스트 기반의 그래프구현
