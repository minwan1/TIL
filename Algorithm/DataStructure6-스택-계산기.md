## 계산 프로그램 구현
### 수식의 표기법: 중위(infix), 전위(prefix), 후위(postfix)표기법
수식을 이루는 피연산자는 한자리 숫자로만 이뤄진다고 가정합니다. 즉 1,3은 피연산자가 될 수 있지만, 24와 35는 피연산자가 될 수 없다. 이렇게 제한을 둔 이유는 당장 중요하지 않은 부분에 신경을 덜쓰기 위한것이다. 수식을 표기하는 방법에는 다음과 같이 세가지 종류가 있다

* 중위 표기법(infix notation) 예) 5+2/7
* 전위 표기법(prefix notation) 예) +5 / 27
* 후위 표기법(postfix notation) 예) 527/+

우리가 익숙한 표기법은 당연 중위 표기법이다. 전위 표기법과 후위표기법은 먼저 연산이 일어나거나 마지막에 연산을 신경쓰기 떄문에 즉 배치 순서에 따라서 연산순서가 결정되기 때문에 소괄호에 대한 처리가 불필요하다.

다음은 중위 표기법의 수식이다
(1+2) * 7

이 중위 표기법의 수식은 다음과 같이 전위 표기법, 후위 표기법의 수식으로 얼마든지 변환이 가능하다.
(1+2) * 7 전위 표기법 * + 1 2 7
(1+2) * 7 후위 표기법 1 2 + 7 *

이렇게 변환이된 전위표기법의 수식과 후위 표기법의 수식을 대상으로 한 계산기를 구현하는것이, 중위표기법이 수식을 대상으로 한 계산기의 구현보다 훨씬 수월하다. 이유는 우선순위를 신경쓰지 않아도 되고, 소괄호도 처리할 필요가 없기 때문이다. 참고로 우리가 사용하는 계산기들도 후위표기법으로 변경되어 계산 되어진다.

### 중위 표기법을 후위 표기법으로 바꾸는 방법 1/2: 소괄호를 고려하지 않고

우리가 구현할 계산기는 다음의 과정을 거쳐서 연산을 진행하도록 할 계획이다.
1. 중위 표기법의 수식을 후위 표기법의 수식으로 바꾼다
2. 후위 표기법으로 바뀐 수식을 계산하여 그 결과를 얻는다.
```
 5 + 2 / 7
````

위에 방식을 후위 표기법으로 변환 할 것이다. 수식과 연산자를 차례대로 배열과 쟁반에 담을것이다. 위에 먼저 처음으로 담을 숫자는 5이다.
```
 + 2 / 7        수식자리:5 연산자자리:
```
그다음은 + 연산자이다.
```
  2 / 7        수식자리:5 연산자자리:+
```

```
  / 7        수식자리:5,2 연산자자리: +
```
```
 7        수식자리:5,2 연산자자리:+,/
```
```
       수식자리:5,2,7 연산자자리:+,/
```

만약 연산자의 쟁반에 먼저 들어가있는 연산이 우선순위가 더낮으면 그대로 계속계속해서 쟁반에 들어가게되면된다. 그래서 위와같은경우네느 /보다 +가 우선순위가 낮기때문에 그대로 + 다음에 / 가 들어가게 된다. 그리고 이것을 이제 후위표기법을 만들기 위해서 연산자 자리의 쟁반에들어 있는 연산자들을 수식자리로 옮기면된다.(보통 쟁반에 2개이상 들어가있을 경우가 거의없다) 쟁반(스택)의 원리로 들어갔기 때문에 뒤에서부터 들어가게되면된다.


```
5,2,7,/,+
```

위 부분에서 연산자 우선순위부분에서 설명 하지 않은경우 우선순위가 같은 경우가있다. 예를들어 쟁반에 +가 먼저 들어가있고 나중에 - 가따라온다면 둘은 우선순위가 같은경우이다. 사칙연산에서는 우선순위가 같으면 먼저 나온 연산자를 실행한다. 그럼으로 우선순위를 높이려면 쟁반에 +연산자를 배열로 옮겨주고 - 연산자를 쟁반에 놓는다.


### 중위 표기법을 후위 표기법으로 바꾸는 방법 2/2: 소괄호를 고려하고

(1+2+3)/4
후위 표기법의 수식에서는 먼저 연산이 이뤄져야 하는 연산자가 뒤에 연산이 이뤄지는 연산자보다 앞에 위치해야한다. 따라서 위의 수식에서는 / 연산자보다 + 연산자와 * 연산자가 먼저 쟁반에서 빠져나가야한다.

![](https://i.imgur.com/dsHsCXb.png)
위와같이 소괄호도 연산자로 인식하고 쟁반에 올려 놓는다. 숫자들은 그전과같이 바로 수식의 자리로 들어가면된다.

![](https://i.imgur.com/Sv4zDSu.png)
괄호 연산자가 등장할 떄까지 쟁반 위에 남아 있어야 하기 댸문에 사칙 연산자들보다 연산 우선순위가 낮다고 간주한다. 지금 현재 쟁반에 쌓여있는 + 연산자보다 * 연산자의 우선순위가 높으므로 다음과 같이 + 연산자 위에 * 연산자를 올려 놓아야한다. 만약에 + 연산자보다 우선순위가 낮은 연산자가 등장했다면 이전에 해오던 데로 + 연산자를 변화된 수식의 자리로 이동시키고 나서 새로운 연산자를 쟁반에 올려놔야한다.
이어서 숫자 3을 변환된 수식의 자리로 옮기고 ) 연산자를 쟁반위로 옮길 차례이다. 그런데 이때 등장하는 ) 연산자가 의미하는 바는 소과호의 끝을 의미한다. ( 연산자 이후에 쌓인 연산자들을 쟁반에서 꺼내어 변환된 수식의 자리로 옮겨야 한다.
이제 남은것은 / 연산자와 숫자 4의 처리이다. 기존그대로 쟁반과 수식의자리로옮기고 최종적으로 /를 가지고와 수식으로 옮기게되면 아래와같이 완성되게 된다.
![](https://i.imgur.com/8AIxVzG.png)

### 중위 표기법을 후위 표기법으로 바꾸는 프로그램의 구현
먼저 후위 표기법으로 변환을 처리하는 함수를 구현해야한다.

```c
void ConvToRPNExp(char exp[]){ //후위 표기법의 수식으로 변환
  ....
}

```

함수의 매개변수 형과 반환형을 위와 같이 결정한 이유는 중위 기표법의 수식을 담고 있는 배열의 주소 값을 인자로 전달하면서 ConvToRPNExp함수를 호출하면, 인자로 전달된 주소 값의 배열에는 후위 표기법으로 바뀐 수식이 저장된다. 따라서 함수 ConvToRPNExp는 다음 형태로 호출되어진다.

```java
int main(void){
  char exp[] = "3-2+4"; //중위 표기법
  ConvToRPNExp(exp); //후위볍기법으로 변경!
  ...
}
```
ConvToRPNExp를 정의하기전에 거기에 사용되는 몇개의 함수를 먼전 선안하겠다

```c
int GetOpPrec(char op) // 연산자의 우선순위 정보를 반환한다.
{
  switch(op){
    case '*':
    case '/':
      return 5; //가장 높은 우선순위
    case '+':
    case '-':
      return 3; // 중간 우선순위
    case '(': // 가장 낮은 연산순위
      return 1;
  }

  return -1; //등록되지 않은 연산자알림
}

```

다음은 GetOpPrec 함수의 호출결과를 바탕으로 두연산자의 우선순위를 비교하여, 그결과를 반환하는 함수이다.

```c
int WhoPrecOp(char op1, char op2){
  int op1Prec = GetOpPrec(op1);
  int op2Prec = GetOpPrec(op2);

  if(op1Prec > op2Prec)
    return 1;
  else if(op1Prec < op2Prec)
    return -1;
  else
      return 0; //우선순위가 같다면
}
```

다음은 위에서 언급함 ConvToRPNExp 함수이다

```c
void ConvToRPNExp(char exp[]){ //후위표기법으로 전환해주는 함수
//문자열 배열이들어옴

  Stack stack;
  int expLen = strlen(exp); //strlen은 길이를 변환하는 함수
  char * convExp = (char*)malloc(expLem+1); //변환된 수식을 담을공간

  int i, idx = 0;
  char tok, popOp;


  //memset 함수는 특정값으로 초기화하는것, 여기에서는 0으로 초기화
  memset(convExp, 0, sizeof(char)*expLen+1); // 할당된 배열을 0으로 초기화

  for(int i=0; i<expLen; i++){
    tok = exp[i];  //exp로 전달된 문자열 하나씩 tok에 저장

    if(isdigit(tok)){
      convExp[idx++] = tok;
    }else{
      switch(tok){
        case '()':
          SPush(&stack, tok);
          break;
        case ')':
          while(1){
            popOp = SPop(&stack);
            if(popOp == '(')
              break;

            convExp[idx++] = popOp; // 배열 convExp에 저장한다
          }
          break;

        case '+':
        case '-':
        case '*':
        case '/':
        while(!SIsEmpty(&stack) && WhoPrecOp(Speek(&stack),tok)>=0)
          convExp[idx++] = SPop(&stack);

        SPush(&stack, tok);
        break;

      }
    }
  }

  while(!SIsEmpty(&stack))
    convExp[idx++] = SPop(&stack);

  strcpy(exp, convExp);// 변환된 수식을 exp에 복사한다
  free(convExp); // 그리고 소멸
}

```

### 후위 표기법으로 표현된 수식의 계산방법

이제 남은 일은 변환된 후위 표기법의 수식을 계산하여 그결과를 얻는것이다.

```
3 + 2 * 4
이를 후위표기법으로하면
324*+
```
후위 표기법에서는 다음의 기준을 근거로 피연산자를 선택하게 된다. "후위 표기법의 수식에서는 연산자의 앞에 등장하는 두 개의 숫자가 피연산자이다."
즉 먼저 곱셈이 진행되는데 연산되는 피연산자는 2,4이다.
3 8 +
그리고 마지막으로 덧셈을 해주게되면 연산이 완료되게 된다.좀더 어려운 문제로 예를 하나 더들겠다.
```
중위 표기법 : (1*2+3) / 4
후위 표기법 : 12*3+4/
```
위의 후위 표기법을 계산식으로 진행 해보겠다

```
12*3+4/
23+4/
54/
5/4
```
다시 한번 프로그램으로 옮기기 위한 수식의 계산방법의 기본원칙을 세가지를 정리해보겠다.
* 피연산자는 무조건 스택으로 옮긴다.
* 연산자를 만나면 스택에서 두개의 피연산자를 꺼내서 게산을 한다.
* 계산결과는 다시 스택에 넣는다

3 2 4 * + 후위표기법을 수식의 계산방법으로 계산해보자
![](https://i.imgur.com/2lYEuqz.png)
먼저 3,2,4가 모두 피연산자이니 다음 그림과 같이 모두 차례로 스택에 옮긴다.
그다음 쟁반(스택)에서 숫자 2개를 꺼내어 배열에 남은 연산자로 차례대로 연산한다. 여기에서 주의 할점은 위에서 꺼낸 4*2로 연산하는게 아니라 나중에나온것이 앞으로 오고 처음에 끄낸게 뒤로간다. 2*4연산으로 해야한다는 소리이다. 그다음은 3+8 , 11의 값을 얻는다. 이를 바탕으로 함수를 만들것이다.

```c
int EvalRPNExp(char exp[]){ //후위 표기법의 수식을 계산하여 그결과를 반환

  Stack stack;
  int expLen = strlen(exp);
  int i;
  char tok, op1, op2;

  StackInit(&stack);

  for(i=0;i<expLen;i++){
    tok = exp[i];
    if(isdigit(tok)){
      SPush(&stack, tok - '0'); //정수면 숫자로 변환후 스택에 Push
    }else{ // 정수가 아닌 연산자라면,
      op2 = SPop(&stack); // 스택에서 두 번째 연산자를 꺼낸다.
      op1 = SPop(&stack); // 스택에서 첫 번째 연산자를 꺼낸다.

      switch(tok){ // 연산하고 그결과를 다시 스택에 PUSH!
        case '+':
          SPush(&stack, op1+op2);
          break;
        case '-':
          SPush(&stack, op1+op2);
          break;
        case '*':
          SPush(&stack, op1+op2);
          break;  
        case '/':
          SPush(&stack, op1+op2);
          break;

      }
    }

  }

  return SPop(&stack); // 마지막 연산결과를 스택에서 꺼내서 리턴

}
```
위에 함수는 주소값을 인자로 받아 결과 값을 리턴해주는 함수이다.
