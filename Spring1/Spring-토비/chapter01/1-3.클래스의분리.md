## 프로젝트 실행환경
반드시 먼저 다음 H2 DB프로젝트 Main을 먼저 실행시키고 아래 예제프로젝트를 실행시켜야합니다.
* [H2 DB](https://github.com/minwan1/Spring-toby/tree/master/h2-db)


### 1.3 DAO의 확장
모든 오브젝트는 변한다. 그런데 오브젝트가 다 동일한 방식으로 변하는건 아니고 공통 관심사에 따라 변한다. 지금까지 크게 두가지를 다뤘다.
1. 데이터를 어떻게 접근할것인가
2. 어떻게 데이터베이스를 쉽게 변경할것인가.

위의 소스로 장점은 데이터 접근 방식이 수정된다면 우리는 UserDao를 변경할것이다. 만약 DB에서 꺼내온 정보를바탕으로 뭔가 정보가 수정된다면 그 구현체들 MUserDao, DUserDao가 수정될것이다. 이것은 것으로 보면 서로에게 영향을 안주는것같지만 상속이라는 방법을 사용했기때문에 지독한 의존성을 가진다. 다음에서부터는 그 의존성을 좀더 느슨하게 할것이다.

#### 1.3.1 클래스의분리
DB 커넥션과 관련된 부분을 서브클래스가 아니라, 아예 별도의 클래스로 분리해보자. 하지만 여전히 UserDao 에서 클래스를 생성해야하기때문에 UserDao는 ConnectionMaker클래스에 의존적이다.
![](https://i.imgur.com/2MsaNa5.png)

#### 1.3.2 인터페이스의 도입

위에서 결국엔 클래스를 분리해도 데이터베이스를 연결하기 위해서는 지독한 의존성을 가지게된다. 이문제를 해결하기위해서는 서로 긴밀하게 연결되어 있지 않도록 중간에 추상적인 느스한 연결고리가 필요하다. 추상화란 어떤 것들의 공통적인 성격을 뽑아내어 이를 따로 분리하는 작업이다. 자바가 추상화를 위해 제공하는 가장 유용한 도구는 바로 인터페이스이다. 인터페이스를 통해 추상화를 하게되면 최소환의 통로를 통해 접근하는 쪽에서는 오브젝트를 만들때 사용할 클래스가 무엇인지 몰라도 된다.

![](https://i.imgur.com/ZBKuVCa.png)

인터페이스를 도입했지만 여전히 자바에서 인터페이스를 통해 객체를 생성할때 아래와같이 new DConnectionMaker(); 선언을 해줘야하기떄문에 근본적인 문제가 해결되지않는다.
```java
public UserDao(){
  connectionMaker = new DConnectionMaker();
}
```
#### 1.3.3 관계설정 책임의 분리
![](https://i.imgur.com/ZBKuVCa.png)
그래서 이러한 근본적인 문제를 해결하기 위해서는 인터페이스를 통해서 처음부터 관계를 설정해주면된다. 아래와같이.

```java
public interface ConnectionMaker {
    public Connection makeConnection() throws ClassNotFoundException, SQLException;
}

public class DConnectionMaker implements ConnectionMaker {
    public Connection makeConnection() throws ClassNotFoundException, SQLException {
        // D 사의 독자적인 방법으로 Connection 을 생성하는 코드
    }
}
public class UserDao {
    private ConnectionMaker connectionMaker; ㅡ> 인터페이스를 통해 오브젝트에 접근, so 구체적 클래스 정보가 필요 없다.

    public UserDao(ConnectionMaker connectionMaker){
        this.connectionMaker = connectionMaker;  
    }

    public void add(User user) throws ClassNotFoundException, SQLException {
        Connection c = connectionMaker.makeConnection();
      ㅡ> 인터페이스에 정의된 메소드를 사용하므로 클래스가 바뀐다고 메소드 이름이 변경 되지 않는다.
    }

    public user get(String id) throws ClassNotFoundException, SQLException {
        Connection c = connectionMaker.makeConnection();
    }
}

```
이제 이렇게 의존성 주입을 해주게되면 ConnectionMaker의 역할을 할 수 있는 어떤 클래스가 들어와도 UserDao기능을 수애할수 있게 된다.


UserDaoTest
```java
public class UserDaoTest{
    public static void main(String[] args) throws ClassNotFoundException, SQLException {
        ConnectionMaker connectionMaker = new DConnectionMaker();
        // UserDao가 사용할 ConnectionMaker 구현 클래스를 결정하고 오브젝트를 만든다.

        UserDao dao = new UserDao(connectionMaker);
        // 1. UserDao 생성
        // 2. 사용할 ConnectionMaker 타입의 오브젝트 제공, 결국 두 오브젝트 사이의 의존관계 설정
    }
}
```

최종적으로 UserDaoTest와같이 UserDao를 즉 3자 호출하는곳에서 의존성 주입을하게되면 아래와같이 불필요한 의존관계를 끊을 수 있게된다. 이렇게되면 어떤 Connection이 들어와도 UserDao를 클래스 수정없이 UserDao클래스 기능을 사용할 수 있게된다.

![](https://i.imgur.com/bvYYyzb.png)

#### 1.3.4 원칙과 패턴

##### 개방 폐쇄원칙
개방 폐쇄 원칙은 깔끔한 설계를 위해 적용 가능한 객체지향 설계 원칙 중의 하나다. 클래스나 모듈은 확장에는 열려 있어야하고 변경에는 닫혀 있어야한다고 할 수 있다. UserDao는 DB연결 방법이라는 기능을 확장하는데는 열려있다. UserDao에는 전혀 영향을 주지 않고도 얼마든지 확장 가능하다. 잘설계된 객체지향 클래스의 구조를 살펴보면 바로 이 개방 폐쇄 원칙을 아주 잘 지키고 있다. 인터페이스를 사용해 확장 기능을 정의한 대부분의 API는 바로 개방 폐쇄 원칙을 잘 따르고 있다고 볼 수 있다.


##### 높은 응집도와 낮은 결합도

**높은 응집도 (같은 기능끼리 모여있다는것)**
응집도가 높다는것은 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 뜻, 하나의 모듈에서만 변경이 많이 일어나면 다른 모듈은 변경이 필요가 없을때를 말한다. 하나의 클래스에 여러가지 관심사가 모여있다면 그 관심사 하나가 변경되면 다른 영향을 미치짖 않는지 확인해야하는 이중의 부담이 생긴다. 예를들어 기존의 NConnectionMaker를 개선해서 2.0을 만들었다해보자. 그렇게되면 NConnectionMaker를 테스트하기위해서 모든 DAO를 테스트할필요는없다. 높은 응집도때문에 그냥 NConnectionMaker만 테스트해도 충분하다. ConnectionMaker를 분리해서 높은 응집도를 가지고있기 때문이다.

**낮은 결합도**
낮은 결합도는 높은 응집도 보다 더 민감한 원칙이다. 책임과 관심사가 다른 오브젝트 또는 모듈과는 낮은 결합도, 즉 느슨하게 연결된 형태를 유지하는것이 바람직하다. 결합도가 낮아지면 변화에 대응하느 속도가 높아지고, 구성이 깔끔해진다. 또한 확장하기에도 매우 편리하다. 예를들면 위에서 보여준 예제처럼 인터페이스를 통한 ConnectionMaker구현이 있을 수 있다.

**전략패턴**
개선한 UserDaoTest - UserDao - ConnectionMaker 구조를 디자인 패턴의 시각으로 보면 전략 패턴에 해당한다고 볼 수 있다. 전략패턴은 디자인 패턴의 꽃이라고 불릴만큼 다양하게 자주 사용되는 패턴이다. 개방 폐쇄 원칙의 실현에도 가장 잘 들어 맞는 패턴이라고 볼 수 있다. 전략 패턴은 자신의 기능 Context에서,필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용 할 수 있게 하는 디자인 패턴이다.
UserDao는 전략패턴의 컨텍스트에 해당한다. 컨텍스트는 자신의 기능을 수행하는데 필요한 기능 중에서 변경 가능한, DB 연결 방식이라는 알고리즘을 ConnectionMaker라는 인터페이스로 정의하고, 이를 구현한 클래스, 즉 전략을 바꿔가면서 사용할 수 있게 분리했다.

전략패턴은 컨텍스트(UserDao)를 사용하는 클라이언트(UserDaoTest)는 컨텍스트가 사용할 전략 (ConnectionMaker를 구현한 클래스, 예 DConnectionMaker)을 컨텍스트의 생성자등을 통해 제공해주는게 일반적이다.
