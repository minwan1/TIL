## 빠른 탐색을 보이는 해쉬 테이블
이번에 소개하는 내용도 탐색과 관련이 있다는 점에서 트리 탐색의 연장으로 볼 수 있다.

**테이블(Table) 자료구조의 이해**
앞서 소개한 AVL 트리는 탐색과 관련하여 매우 만족스러운 성능이였다. 하지만 탐색키의 비교과정을 거치면서 찾는 대상에 가까워지는 방식이기 때문에, 원하는 바를 단번에 찾아내는 방식이라고 말하기는 어렵다. 이러한 상황때문에 AVL트리의 성능에 만족하지 못할 수 도있다.  이러한 상황에서 도입을 검톨할수 있는 자료구조가 바로 테이블이다.

AVL트리의 탐색 연산이 O(log2n)의 시간 복잡도를 뵈는 반면, 테이블 자료구조의 탐색 연산은 O(1)의 시간 복잡도를 보이니, 바로 단번에 키값으로 데이터를 조회할 수 있다. 다음은 테이블의 원리를 설명할 것 이다.


![](https://i.imgur.com/2kDDYZf.png)
다음 표는 저장되는 데이터는 키와 값이 하나의 쌍을 이룬다. 그리고 키가 존재하지 않는 값은 저장할 수 없다. 그리고 모든 키는 중복되지 않는다. 이렇듯 테이블의 핵심은, 키와 값이 하나의 쌍을 이루어 저장되는 데이터 유형에 있다.
이러한 테이블 자료구조는 현실세계에서도 쉽게 찾을 수 있다. 가장 쉽게 찾을 수 있는 것은 다세대 주택이나 아파트의 우편함이다. 우편함의 경우 호수가 키가되고, 우편함에 들어있는 우편물이 데이터가 된다. 우편함번호를 통해 우편물을 한번에 찾아낸다. 상당히 테이블의 원리와 유사하다.  

**배열을 기반으로 하는 테이블**

```c
#include <stdio.h>

typedef struct _empInfo{
  int empNum; // 직원의 고유 번호
  int age; // 직원의 나이
} EmpInfo;


int main(void){
  EmInfo empInfoArr[1000];
  empInfo ei;
  int eNum;

  printf("사번과 나이 입력 : ");
  scanf("%d %d", &(ei.empNum), &(ei.age));
  empInfoArr[ei.empNum] = ei; // 단번에 저장!

  printf("확인하고픈 직원의 사번 입력 : ");
  scanf("%d", &eNum);

  ei = empInfoArr[eNum];
  printf("사번 %d, 나이 %d, \n", ei.empNum, ei.age);

  return 0;



}
```

위 소스 코드는 아래의 코드같은 원리로 탐색, 저장되었다.
* 저장 empInfoArr[ei.empNum] = ei;
* 탐색 ei = empInfoArr[eNum];
따라서 위의 배열은 테이블의 구현결과라 할 수 있다. 하지만 고유의번호를 100000~999999일경우가 있다. 그러기위해서는 큰배열이 필요할것이다. 이러한 문제점은 앞서 보인 테이블의 예에서 테이블의 핵심인 해쉬와 관련된 내용이 빠졌기 때문에 등장한것이다.

***테이블에 의미를 부여하는 해쉬 함수와 충돌문제***
위예제에서 보인 테이블과 관련하여 지적한 문제점 두가지를 정리하면 다음과 같다.
* 직원 고유번호의 범위가 배열의 인덱스 값으로 사용하기에 적당하지 않다.
* 직원 고유번호의 범위를 수용할 수 있는 매우 큰배열이 필요하다.

이 두 가지 문제를 동시에 해결해주는 것이 바로 '해쉬함수'이다. 만약 다음과 같은 가정이 있다고 가정하자.
'직원의 고유 번호는 입사년도 네자리와 입사순서 네자리로 구성된다.'        
예를 들어서 2012년에, 그리고 이회사에 세 번째로 입사한 직원의 고유번호는 20120003이 되고, 뒤를 이어서 입사한 직원의 고유 번호는 20120004가 된다. 이렇듯 입사순서를 네 자리로 구성한것을 보면 직원의 수가 언젠가는 천명을 넘어설 수 있다는 생각을 한 모양인데, 이는 훗날의 이야기이고, 실제로는 백 명 이상을 채용할지도 의문인 상황이다. 이는ㄴ 먼 훗날의 이야기이고 실제로는 백 명 이상을 채용할지도 의문인 상황이다. 따라서 배열 길이의 최소화를 위해 노력한다는 가정하에 예제를 재구현하였다.

TableHashFunction.c
```c
typedef struct _empInfo{
  int empNum; // 직원의 고유 번호
  int age; // 직원의 나이
}EmpInfo;

int GetHashValue(int empNum){
  return empNum % 100;
}

int main(void){
  EmpInfo empInfoArr[100];

  Empinfo emp1 = {2012003, 42};
  EmpInfo emp2 = {20130012, 33};
  EmpInfo emp3 = {20170049, 27};

  EmpInfo r1, r2, r3;

  //키를 인덱스 값으로 이용해서 저장
  empInfoArr[GetHashValue(emp1.empNum)] = emp1;
  empInfoArr[GetHashValue(emp1.empNum)] = emp2;
  empInfoArr[GetHashValue(emp1.empNum)] = emp3;

  // 키를 인덱스 값으로 이용해서 탐색
  r1 = empInfoArr[GetHashValue(20120003)];
  r2 = empInfoArr[GetHashValue(20120003)];
  r3 = empInfoArr[GetHashValue(20120003)];

  // 탐색 결과 확인
  printf("사번 %d, 나이 %d \n", r1.empNum, r1.age);
  printf("사번 %d, 나이 %d \n", r2.empNum, r2.age);
  printf("사번 %d, 나이 %d \n", r3.empNum, r3.age);
  return 0;

}

```
```
사번 2012003, 나이 42
사번 2013012, 나이 33
사번 2017049, 나이 27
```

위의 예제에서 길이가 100인 배열을 선언하였다. 직원의 수가 100명을 넘길 경우를 고려하지 않은 것이다. 그리고 데이터의 저장위치를 결정하는데 있어서 직원의 고유 번호를 활용하되, 다음함수를 이용해서 가공처리를  거쳤다
```c
int GetHashValue(int empNum){
  retrun empNum % 100;
}
```
위의 함수에서 100으로 % 연산을 하는것은 여덟 자리의 수로 이뤄진 직원의 고유번호를 두자리의 수로 변경한다는 의미이다. 실제로는 앞의 숫자 여섯개를 잘라낸것이지만 이것도 변경의 일종이다. 그럼 100으로 나눠서 그 나머지를 취하는 이연산을 함수 f(x)라하면 다음과같이 표현할 수 있다.


![](https://i.imgur.com/7NFvLBX.png)
위 그림에서 보이는 f(x)를 가리켜 '해쉬함수'라 한다. 그리고 이러한 해쉬함수는 넓은 범위의 키를 좁은 범위의 키로 변경하는 역할을 한다. 실제로 위의 예제에서는 해쉬함수와 관련해서 흔히 거론되는 % 연산자를 이용하여 여덟자리의 키를 두 자리의 키로 바꾸었다.

그럼 이어서 위 예제의 문제점을 생각해보자. 만약 직원의수가 100명을 넘어선 것이다. 그리하여 직원번호 20210103이 형성되었고 이로 인해 2번 째 그림과 같은 문제가 발생했다.

2번 째 그림에서 보이듯이 서로 다른 두개의 키가 해쉬함수를 통과하였는데 그결과가 03으로 모두 동이하다. 이러한 상항을 가리켜 충돌(conllision)이라하는데, 이러한 충돌은 배열의 길이를 늘리는 등의 방법으로 피해야할 상황이 아니다. 배열의 길이를 늘리는 방법으로 충돌을 완전히 피할 수 있을지 의문도 들지만, 완전히 피할 수 있다 하더라도 매우 비합리적인 방법일 수 밖에 없다. 때문에 충돌은 피해야 하는 상황이 아니라 해결해야 하는 상황인것이다.

먼저 어느정도 갖춰진 테이블과 해쉬의 구현을 해보겠다.

**어느 정도 갖춰진 테이블과 해쉬의 구현의 예**

```c
typedef struct _person{
    int ssn;//key
    char name[STR_LEN];
    char addr[STR_LEN];
} Person;
```
위의 구조체 변수는 테이블(map)에 저장될 값이다. 그리고 그중에서 ssn을 주민등록번호 키로 결정하였다.
```c
#ifndef Slot_h
#define Slot_h

#include "Person.h"

typedef int Key; // 주민등록번호
typedef Person * Value;

enum SlotStatus {EMPTY, DELETED, INUSE};

typedef struct -slot{
    Key key;
    Value val;
    enum SlotStatus status;
}Slot;


#endif /* Slot_h */


```
다음은 슬롯네임이라는 구조체정의다. 슬롯이란 테이블을 이루는, 데이터를 저장할 수 있는 각각의 공간을 말하며 키와 벨류를 저장하게된다. 그리고 위 typdef선언에서도 보이듯이 키와 값은 다음과 같이 정의했다.
* 키 - 주민등록번호
* 값 - Person 구조체 변수의 주소값
그리고 enum선언을 통해서 슬롯의 상태를 나타내는 상수 EMPTY, DELETED, INUSE가 정의되었다.
* EMPTY - 비어있음
* DELETED - 데이터가 저장된바 있으나 현재는 비워진상태
* INUSE - 데이터가 저장된 상태


```c
typedef struct new_table{
    Slot tbl[MAX_TBL];
    HashFunc * hf;
}Table;

//테이블의 초기화
void TBLInit(Table * pt, HashFunc * f);

//테이블에 키와 값을 저장
void TBLInsert(Table * pt,Key k, Value v);

//키를 근거로 테이블에서 데이터 삭제
Value TBLDelete(Table * pt,Key k);

//키를 근거로 테이블에서 데이터 탐색
Value TBLSearch(Table * pt, Key k);
```
위는 실질적인 테이블 구조체를 정의하고 또 그것을 동작하게해주는 메소드들이다.

## 좋지 해쉬 함수의 조건
좋은 해쉬 함수의 조건을 언급하기에 앞서 좋은 해쉬함수를 사용한 결과와 좋지 않은 해쉬 함수를 사용한 결과를 ㅂ교해 보이겠다.
![](https://i.imgur.com/98IV8wz.png)

위의 검은색 부분들은 데이터가 채워진 슬롯을 의미한다. 반대로 흰영역은 빈 슬롯을 의미한다. 첫번째 그림은 데이터가 테이블의 전체영역에 고루 분포 되어 있음을 알 수 있다. 고루 분포 된다는것은 그만큼 충돌이 발상핼 확률이 낮다는것을 의미한다.
두번째 그림은 테이블의 특정영역에는 데이터가 몰린 상황을 보이고 있다. 이는 해쉬함수가 특정영역에 데이터가 몰리도록 '해쉬값'을 생성한 결과이다.
좋은 해쉬값을 만들기위해서는 키의 일부분을 참조하여 해쉬 값을 만들지 않고, 키 전체를 참조하여 해쉬값을 만들어내면 좋다.

**자릿수 선택(Digit Selection) 방법과 자릿수 폴딩(Digit Folding) 방법**
좋은 해쉬 함수이 디자인 방법은 키의 특성에 따라 달라진다. 때문에 해쉬 함수의 디자인에 있어서 절대적인 방법은 존재하지 않는다. 다만 위의 말대로 키전체를 참조하는 방법과 관련하여 다양방법이 존재한다.
그중 하나는
여덟 자리의 수로 이뤄진 키에서 다양한 해쉬 값 생성에 도움을 주는 네자리의 수를 뽑아서 해쉬값을 생성한다.
키의 특정 위치에서 중복의 비율이 높거나, 아예 공통으로 들어가는 값이 있다면, 이를 제외한 나머지를 가지고 해쉬값을 생성하는 지극히 상식적인 방법이다.

다른 방법으로는 자릿수 폴딜 방식이있다. 만약 2 7 / 3 4 / 1 9 이 적혀있는 종이가 있다고 가정해보자. 그러면 27과 34와 19가 겹치게 된다. 이렇게 겹친 두 자릿수 숫자를 더하면 그결과는 80이 되는데. 이를 해쉬 값이라하면 이는 여섯 자리의 숫자를모두 반영하여 얻은 결과라 할 수 있다.


## 충돌 문제의 해결책
다음은 테이블의 핵심주제라 할 수 있는 충돌문제를 고민할 차례이다. 예를들어 충돌이 발생하면, 충돌이 발생한 그자리를 대신해서 빈자리를 찾아야한다. 다만 빈자리를 찾는 방법에 따라서 해결책이 구분될 뿐이다.

**선형 조사법과 이차 조사법**
충돌이 발생했을 대 그 옆자리가 비었는지 살쳐보고, 비었을 경우 그자리에 대신 저장하는것이 바로 '선형 조사법'이다. 예를들어서 다음과 같이 정의된 해쉬 함수 f(x)가 있고 테이블의 내부 저장소가 배열이라고 가정해보자.

* 해쉬 함수      key % 7

그러면 키가 9인 데이터는 해쉬값이 2이므로 다음과같이 인덱스가 2인 위치에 저장이 된다. 이어서 키가 2인 데이터가 등장했다고 가정해보자. 이 경우 해쉬 값이 2이기 때문에 앞서 저장한 키가 9인 데이터와 충돌이 발생한다. 이렇듯 충돌이 발생했을 때 인덱스 값이 3인 바로 옆자리를 살피는것이 선형 조사법이다. 따라서 키가 2인데이터의 저장결과는 2번째 그림과 같다.
![](https://i.imgur.com/jD2AfhJ.png)

물론 옆자리가 비어있지 않을 경우, 한칸더 이동을 해서 자리를 살피게 된다. 정리하면, k의 키에서 충돌 발생시 선형 조사법의 조사 순서는(빈자리 찾는 순서는)다음과 같이 전개 된다.
f(k)+1 -> f(k)+2 -> f(k)+3 -> f(k)+4 ---
그런데 이러한 선형 조사법은 충돌의 횟수가 증가함에 따라서 '클러스터현상', 쉬운 표현으로 특정영역에 데이터가 집중적으로 몰리는 현상이 발생한다는 단점이 있다. 이러한 클러스터 현상은 충돌의 확률을 높이는 직접적인 원인이 된다.

그래서 이러한 문제를 해결하기 위해서 나온것이 이차 조사법이다. 이차 조사법은 옆칸으로이동하기는 하되 제곱으로 이동하면 좀더 공간을 많이 확보할수 있게된다. 예를들자면 아래와같다.
f(k)+1^2 -> f(k)+2^2 -> f(k)+3^2 -> f(k)+4^2 ---
이를 선형 조사법의 조사 순서와 비교하면 그 차이를 쉽게 알 수 있다. 선형 조사법은 충돌 발생시 n칸 옆의 슬롯을 검사한다면, 이차 조사법은 n^2칸 옆의 슬롯을 검사한다. 이렇듯 좀 멀리서 빈공간을 찾으려는 노력이 이차 조사법에 담겨 있다. 물론 이차 조사법에도 나름의 문제가 있지만 이문제는 후에 '이중해쉬'를 소개하면서 업급할것이다.

이번에는 슬롯의 상태 정보를 별도로 관리헤야하는 이유에 대한 이야기이다. 아래그림은 앞서 설명한 선형 조사법의 그림이다. 여기에서 키가 2인상황에 충돌 해결 결과를 보이고 있다. 바로 이상황에서 9인 데이터를 삭제 해보자. 그러면 아래의 세번째 그림과 같이 결과값이 나온다.
![](https://i.imgur.com/8cP7Nlw.png)
위 3번쨰 그림에 슬롯의 상태 EMPTY, DELETED, INUSE 상태로 구성되었고, 인덱스2번은 DELETED상태이고 인덱스 3번은 INUSE상태이고, 나머지는 인덱스의 상태 EMPTY상태이다.
위의 3번째 그림에서 주목해야할것은 삭제된 슬롯의 상태 정보를 DELETED로 두어, EMPTY와 구분하였다는것이다. 이렇듯 EMPTY가 아닌 DELETED로 두어야하는 이유는 키가 2인 데이터의 탐색과정을 살펴보면 알 수 있다.
키가 2인 데이터의 탐색을 진행하거나 저장을 하기위해서는 %7의 해쉬 함수를 거친다. 그리고 그결과로 얻은 2를 인덱스값으로하여 탐색,저장을 진행하게된다. 만약 그위의 슬롯 상태가 EMPTY라면, 데이터가 존재하지 않는다고 판단하여 탐색을 종료한다. 그옆자리는 확인도 하지 않은채 말이다. 반면 DELETED 상태임을 확인한다면 충돌이 발생했음을 의심하여 선형 조사법에 근거한 탐색의 과정을 진행한다. 따라서 다음 두가지 사실을 추가로 정리해야한다.
* 선형, 이차 조사법과 같은 충돌의 해결책을 적용하기 위해서는 슬롯의 상태에 DELETED를 포함시켜야한다.
* 선형, 이차 조사법을 적용하였다면, 탐색의 과정에서도 이를 근거로 충돌을 의심하는 탐색의 과정을 포함시켜야한다.

**이중 해쉬(Double Hash)**
앞서 이차 조사법은 선형 조사법의 문제점을 어느 정도 해결하였지만, 전혀 ㅜㅁㄴ제가 없ㄴㄴ것은 아니다. 이차 조사법의 문제점으로 지적되는 사항은 다음과 같다.
* 해쉬 값이 같으면, 충돌 발생시 빈 슬롯을 찾기 위해서 접근하는 위치가 늘 동일하다.

예를들어서 해쉬 값을 기준으로 f(k)에서 충돌이 발생한다면, 다시 말해서 해쉬값f(k)가 같다면, k가 다르더라도 다음의 순서대로 일정하게 빈슬롯을 찾게된다.
* 첫 번쟤 관찰 위치 f(k)+1^2 : 한칸옆의 슬롯
* 첫 번쟤 관찰 위치 f(k)+2^2 : 네칸옆의 슬롯
* 첫 번쟤 관찰 위치 f(k)+3^2 : 아홉칸옆의 슬롯
* 첫 번쟤 관찰 위치 f(k)+4^2 : 열여섯옆의 슬롯

이렇듯 해쉬 값이 같을 경우, 빈 슬롯을 찾아서 접근하는 위치가 동일하기 때문에, 선형 조사법보다는 낫지만, 접근이 진행되는 슬롯을 중심으로 클러스터 현상이 발생할 확률은 여전히 높을 수 밖에 없다. 이유는 규칙적으로 한칸 네칸 아홉칸 등등으로 증가하는 숫자 때문이다. 이러한 문제를 해결하는 방식으로 '이중해쉬' 방법이 있다. 이는 두 개의 해쉬 함수를 사용하기 때문에 붙여진 이름이다.
**이중해쉬** 방법에서는 **두개의 해쉬함수** 를 마련한다. 하나는 앞서 보인것과 마찬가지로 키를 근거로 저장위치를 결정하기 위한 것이다. 반면 다른 하나는 충돌이 발생했을 때, 몇칸 뒤에서 위치한 슬롯을 살펴 볼지 그거를 결정하는것이다.

* 1차 해쉬함수 : 키를 근거로 저장위치를 결정하기 위한것
* 2차 해쉬함수 : 충돌 발생시 몇칸뒤를 살필지 결정하기 위한것

다음은 확실한 이해를 위해서 이중 해쉬의 두 해쉬 함수를 정의 해보겠다. 먼저 배열을 저장소로 하는 테이블이 존재 한다고 가정하자. 그리고 이 테이블의 해쉬함수는 다음과 같이 정의되어 있다고 본다면, 이는 이중 해쉬의 관점에서 1차 해쉬 함수가 된다
* 1차 해쉬함수 h1(k) = k%15

이렇게 이중 해쉬의 1차 해쉬 함수가 결정되면, 다음 식을 근거로 이중 해쉬의 2차 해쉬함수를 결정하게 된다
* 2차 해쉬 함수 h2(k) = 1 + (k%c)

위의 2차 해쉬 함수식이 절대적인 것은 아니지만 일반적인 형태라고는 할수 있다. 그럼 2차 해쉬 함수의 상수를 c를 결정하기 위해서 위의 두 해쉬 함수를 나란히 놓아 보겠다.

* 1차 해쉬 함수 h1(k) = k%15
* 2차 해쉬 함수 h2(k)=1+(k%c)

1차 해쉬 함수를 %15로 결정한 이유는 배열의 길이가 15라고 예상해 볼 수 있다. 이런 경우 c는 15보다 작은, 그러면서도 소수(prime number)중 하나로 결정하게 된다. 따라서 다음과 같이 1차 해쉬 함수와 2차 해쉬함수를 결정할 수 있다.

* 1차 해쉬 함수 h1(k) = k%15
* 2차 해쉬 함수 h2(k) = 1+(k%7)

여기에서 c를 7로 결정해도 다른값으로 결정해도 무리가 없다. 그럼 2차 해쉬 함수를 결정하는 일반적인 형태에 대해서 새악ㄱ해보자

h2(k) = 1+(k%c)

먼저 1을 더하는 이유는 2차 해쉬 값이 0이 되는것을 막기 위해서이다. 충돌 발생 이후에 다른 자리를 살피는 상황에서 2차 해쉬값이 0이 되면 안되기 때문이다. 1차해쉬 함수인 %15를 근거로 15보다 작은 소수로 c를 결정하는 이유는 가급적 2차해쉬값이 1차 해쉬값을 넘어ㅅ지 않게 하기 위함이다. 예를들어 1차 해쉬의 최대값이 14인데 2차 해쉬의 최대값이 32라면 빈자리를 찾아서 몇바퀴를 돌아야 할지 모르기 때문이다. 그다음은 소수로 그값을 결정하는 이유는 클러스터 현상이 발생할 확률이 적어진다는 통계에 근거 하기 때문이다.

그럼 2차해쉬 함수의 활용에 대한 예를 하나들면 앞서 정의한 1차 해쉬함수에 세계의키 3, 18, 33을 적용하여 해쉬 값을 구하면 된다.
* h1(3) = 3 % 15 = 3
* h1(18) = 18 % 15 = 3
* h1(33) = 33 % 15 = 3

때문에 키가 3,18,33인 데이터를 순선대로 저장하면, 키가 18인 데이터를 저장할때, 그리고 키가 33인데이터를 저장할때 충돌이 발생한다. 따라서 이 두개의 키를 대상으로 2차 해쉬값을 계산 해보겠다.

* h2(18) = 1 + 18 % 7 = 5
* h2(33) = 1 + 33 % 7 = 6

위에서 보이듯이 1차 해쉬값이 같아도 2차 해쉬 값은 다르다. 그리고 이 2차 해쉬값을 근거로 빈슬롯을 찾는 과정은 각각 다음과 같이 전개가 된다.
* h2(18) -> h2(18)+5*1 -> h2(18)+5*2 -> h2(18)+5*3...
* h2(33) -> h2(33)+6*1 -> h2(33)+6*2 -> h2(33)+6*3...

이렇듯 2차 해쉬 값이 크기 만큼 건너뛰면서 빈슬롯을 찾게 되므로, 키가 다르면 건너 뛰는 길이도 달라진다. 따라서 클러스터 현상의 발생확률을 현저히 낮출 수 있다. 참고로 실제로도 이중 해쉬는 이상적인 충돌 해결책으로 알려져 있다.

**체이닝(Chaining)**
다음 체이닝 해결책은 앞서 설명한 방법들과 해결방식이 근본적으로 다르다. 앞서 소개한 유형의 방법들을 가리켜 '열린 어드레싱 방법'이라 하는데, 이는 충돌이 발생하면 다른 자리에 대신 저장한다는 의미가 담겨 있다. 반명 이유형은 '닫힌 어드레싱 방법'이라한다. 그리고 여기에는 무슨일이 있어도 자신의 자리에 저장을 한다는 의미가 담겨 있다. 이것은 충돌이 발생해도 자신의 자리에 저장한다는 소리이다. 이것이 가능한 이유는 충돌나는 자리에 여러자리를 마련하면된다. 여러개의 자리를 마련하는 방법으로는 배열을 이용하는 방법과 연결리스트를 이용하는 방법이 있다.

![](https://i.imgur.com/bJlFp3s.png)
위 첫번 째 그림에서 보이듯이 2차원 배열을 구성해서, 해쉬 값 별로 다수의 슬롯을 마련할 수 있다. 하지만 이는 닫힌 어드레싱 방법중에서 흔히 거론되는 방법이 아니다. 충돌이 발생하지 않을경우 메모리 낭비가 심하고, 또 충돌의 횟수를 결정해야 하는 부담도 있기 때문이다. 따라서 '체이닝'이라는, 2번째 그림에서 보이듯이 연결리스틑 이용해서 슬롯을 연결하는 방법이 닫힌 어드레싱 방법을 대표한다.

위 2번째 그림에서 보이듯이, 슬롯을 생성하여 연결리스트의 모델로 연결해나가는 방식으로 충돌 문젤를 해결하는것이 '체이닝' 방법이다. 그림에서 보듯이 체이닝 방법을 적용하면 하나의 해쉬 값에 다수의 슬롯을 두사가 있다. 따라서 탐색을 위해서는 동일한 해쉬값으로 묶여있는 연결된 슬롯을 모두 조사해야한다는 불편이 따른다. 하지만 해쉬함수를 잘정의 한다면, 그래서 충돌의 확률이 높지 않다면 연결된 슬롯의 기링
는 부담스러운 정도가 아닐 것이다.

***충돌 문제의 해결을 위한 체이닝 구현***
앞서 구현한 테이블을 확장하는 형태로 구현하기로 하겠다.
* Person.h Person.c 슬롯에 저장할 데이터 관련 헤더 및 소스 파일
* Slot.h, Table.h, Table.c 테이블 관련 헤더 및 소스파일
그리고 동일한 해쉬값의 슬롯을 연결리스트로 연결하기 위해서,Chapter 04에서 구현한 다음 연결리스트 DLinkedList.h, DLinkedList.c

이전에 보인 Table.h와의 가장 큰 차이점은, 테이블의 저장소였던 slot형 배열을 List형 배열로 바꾸었다는점이다. 이를 위해서 헤더 파일 DLinkedList.h를 포함하는 선언문도 추가하였다. 하지만 여기서 연결리스트와 구조체 Slot의 관계를 고민해야한다. 우리가 고민해 볼 수 있는 모델 두가지중 하나는 다음과 같다. 이는 구조체 Slot을 연결리스트의 노드로 활용하는 방안이다. 다음은 그소스이다.

```c

typedef struct -slot{ // 구조체 Slot이 연결리스트의 노드 역할을 겸하는 구조
  Key key;
  Value val;
  struct -slot * next; // 다음 노드를 가리키는 포인터 변수
}
```
이와 비슷한 방법 또한 존재한다.

다음은 슬롯과 노드를 구분하는 방법이다.
```c
typedef Slot * Data;

typdef struct _node{
  Data data;
  struct _node * next;
}Node;
```

크게 체이닝을 구현하느 방법은 두가지이다.
* 슬롯이 연결 리스트의 노드 역할을 하게 하는 방법
* 연결리스트의 노드와 슬롯을 구분하는 방법

이중에서 노드와 슬롯을 구분하는 방법을 선택해 구현할 것이다.
