
<!-- TOC -->

- [자바와 웹](#자바와-웹)
    - [애플릿](#애플릿)
    - [서블릿](#서블릿)
    - [JSP](#jsp)
    - [웹이란](#웹이란)
        - [웹 서비스란](#웹-서비스란)
        - [RESTful 기반 웹서비스](#restful-기반-웹서비스)
        - [컨테이너](#컨테이너)
            - [서블릿 컨테이너](#서블릿-컨테이너)
            - [JSP컨테이너](#jsp컨테이너)
    - [HTTP 프로콜의 이해](#http-프로콜의-이해)
        - [HTTP란?](#http란)
        - [HTTP 요청정보](#http-요청정보)
            - [HTTP 요청방식](#http-요청방식)
            - [HTTP 요청 URI](#http-요청-uri)
            - [HTTP 응답정보](#http-응답정보)

<!-- /TOC -->

# 자바와 웹
## 애플릿
자바 애플릿은 응용을 뜻하는 application과 작다는 의미의 접미사 let을 조합한 합성어로 자바 언어로 작성된 소프트웨어를 뜻합니다. 웹 상에서 실현하게 해 주는 응용 프로그램들이 자바 애플릿입니다. 좀 더 쉽게 말해 HTML 위에 자바 응용 프로그램을 올려 구동되는것을 말합니다. 초창기 웹은 정적인 페이지만 보여줄 수 있었습니다. 그런데 자바 언어로 구현된 애플릿이 등장하면서 소규모 애니메이션, 그림, 주가정보 표시등의 간단한 기능을 처리하는 프로그램을 만들어 사용할 수 있게 되었습니다.

## 서블릿
애플릿이 자바의 성장을 이끌었지만, 클라이언트 측에 내려 받아서 실행되는 약점이 있었다. 서블릿은 클라이언트 웹브라우저를 통해 요청하면 서버에서 실행한 후 결과값만 클라이언트로 전송합니다. 
또한 HTTP 프로토콜로 통신하는 웹의 특징과 속성들을 자유롭게 활용할 수 있는 api를 제공함으로써, 클라이언트의 요청과 서버의 응답에 관한 처리를 작업할 수 있게 했습니다.

## JSP
JSP는 서블릿과 똑같은 기능을 가지고 있다. 차이가 있다면 표현하는 방법과 웹 애플리케이션에서의 역할이 다르다. 첫 번재 차이는 서블릿은 완벽하게 자바언어로 구현해야하지만, JSP는 HTML페이지 안에서 스크립트 형태로 구현해야한다. 또 한, 일부 서블릿 객체는 변수 선언과 초기화 작업 없이 바로 사용해서 코드가 훨씬 간단할 수 있다.

두번째 차이는 서블릿은 컨트롤러 페이지를 만들때 사용하지만 JSP는 HTML 페이지 안에서 스크립트 형태로 구현한다. 



## 웹이란
###  웹 서비스란
일반적으로 웹서비스란 네트워크상에 분산된 자원들을 이기종 간에 서로 연동하여 자운을 공유하기 위한 추상적인 서비스 형태를 말함.

### RESTful 기반 웹서비스
RESTful웹서비는 ROA(Resource Oriented Architecture)개념을 실형하기 위한 리소스 중심의 표현, 전달 접근방식의 기술이다.

### 컨테이너
서블릿과 JSP과 같은 웹서버 애플리케이션들은 동적 콘테츠를 생성하는 웹 컴퍼넌트입니다. 이러한 웹 컴포넌트를 저장하는 저장소 역할, 메모리 로딩, 객체 생성 및 초기화 등 서블릿의 생명주기를 괄리하고 jSP를 서블릿으로 변환하는 기능을 하는것이 바로 컨테이너이다.



#### 서블릿 컨테이너
서블릿 컨테이너는 클라이언트의 요청에 따라 서블릿을 수행하는 프로그램이다. 

서블릿을 수행하려면 다음과 같은 환경이필요하다.
1. 자바 수행 환경
2. 웹 서버
3. 서블릿 컨테이너

#### JSP컨테이너
JSP컨테이너는 JSP를 서블릿으로 변환하는 프로그램이다. JSP컨테이너 역시 서블릿으로 구현된 프로그램이다.
JSP를 수행하려면 아래와같은 환경을 구성해야한다.

1. 자바 수행 환경
2. 웹서버
3. 서블릿 컨테이너
4. JSP 컨테이너

![JSP처리과정](/assets/JSP처리과정.jpg)

## HTTP 프로콜의 이해
웹은 서버와 클라이언트로 구성되며 서로간에 HTTP 프로토콜을 기반으로 동작한다. 따라서 HTTP 프로토콜에서 규정하는 서버와 클라이언트간에 통신 방식에 대하여 이해하는것은 웹서버 애플리케이션을 개발하고 운영하는데 많은 도움이 된다.

### HTTP란?
HTTP란 TCP/IP 4계층에서 애플리케이션 계층에 해당하는 프로토콜로, 전송계층에서 TCP를 사용하여 웹브라우저와 웹서버간에 통신하는 프로토콜이다.  HTTP는 신뢰성있는 통신과 처리 효율이 높은 프로토콜로서 인터넷환경에서 가장 적합한 통신구조로 인정받았다는 특징이 있다.

**무연결성**
일반적으로 클라이언트가 서버와 통신하려면 연결을 유지한 상태에서 통신을 해야한다. 그러나 HTTP는 연결을 유지하지 않은 상태에서 데이터를 주고받을 수 있다. HTTP는 클라이언트로부터 요청이 들어와 서버가 응답하면 클라이언트와 서버의 연결을 끊고 클라이언트가 새로 요청하면 또 다른 연결을 맺는다. 이때 연결을 이전과는 상관없는 새로운연결이다. 

**무상태성**
HTTP는 무연결 특징이 있어서 요청이 있을 때마다 트랜잭션으로 취급하기 때문에 이전 연결에서 했던 작업내용을 다음 요청에서 그대로 사용할 수 없다. 즉 이처럼 요청마다 서로 다른 연결로 인식되어 요청간에 정보를 공유할 수 없는 상태, 즉 상태 정보가 유지되지 않는 특성을 무상태(stateless)라고한다. 

**요청, 응답**
클라이언트가 서비스를 요청하면 서버는 요청정보를 받고 요청을 처리한 후 응답함으로써 서비스가 완료되는 방식을 말한다.

### HTTP 요청정보

HTTP 요청정보는 웹클라이언트가 웹서버에 서비스를 요청하면 HTTP에 의하여 자동으로 만들어져 서비스를 요청받은 웹서버에 전달된다. 웹 브라우저에서 이러한 액션이 일어나면 HTTP는 요청정보를 생성하여 웹서버에 전달함으로써 서비스 요청이 우러진다. 서비스 요청시 전달되는 HTTP 요청정보는 다음과 같은 구조이다.

![HTTP요청정보구조](/assets/HTTP요청정보구조_cd55yb5lc.jpg)

HTTP 요청정보는 크게 헤더와 몸체로 구성되며 헤더의 가장 첫 번째 줄은 요청 줄로서 3개의 정보가 들어간다. 첫 번째 정보는 요청방식이며 두번째 정보는 요청한 페이지에대한 정보 URI, 세번째는 HTTP버전 정보입니다.

두번쟤 줄은 헤더 정보입니다. 헤더정보는 name : content 형식으로 정보들이 들어가며, 서비스 처리르 위한 웹 클라이언트와 웹서버 간에 공유할 정보들입니다. 

그다음 아래칸은 몸체로 구성됩니다.

#### HTTP 요청방식
요청방식은 웹 클라이언트가 웹서버에 요청하는 서비스 처리 방식을 지정하는것으로 일반적으로 GET, POST가 많이 사용되며, 이외에도 PUT, DELETE등이 있습니다.




**GET**
웹서버에 GET 방식으로 서비스를 요청하는 경우 웹 브라우저의 주소 줄에 URL을 직접 입력하거나 하이퍼링크가 포함된 개체를 클릭할 때입니다. GET방식의 요청은 브라우저에서 캐시가 가능하며 클라이언트가 서버로 전송하는 문자열이 있을 때는 요청정보 헤더의 요청줄에 포함되는 URI 뒤에 ? 기호와 함께 추가되어 전달됩니다. 그래서 URL에 데이터들이 노출되는 문제가있습니다. 그리고 문자열의 크기에 제한이 있습니다. GET은 가장 단순한 요청방식으로 서버에 빠른 속도로 요청할때 사용한다.

**POST**
POST 방식은 데이터가 HTTP요청정보의 몸체에 포함되어 전달된다. 따라서 데이터 크기제한이 없고 화면에 노출되지 않습니다. POST방식은 웹클라이언트측에서 보내는 데이터를 인코딩하고, 서버측에서 디코딩해야하므로 GET방식보다 상대적으로 처리속도가 느리다. 

**PUT**
PUT방식의 서비스 요청은 파일업로드를 할때 이용할 수 있다. POST와 PUT 방식 모두 같은 작업을 수행할 수 있는데요. 일반적으로 서버의 리소스를 새로 생성할대는 POST를 , 서버의 리소스를 수정할때는 PUT방식으로 구분 요청한다.



**DELETE**
서버의 리소스를 삭제하는 작업을 요청할 때 사용하는 방식입니다.


#### HTTP 요청 URI
요청 URI는 웹 클라이언트가 웹서버에 요청한 서비스 문서의 정보입니다. 요청 URI는 네트워크의 자원 정보인 URL의 일부로서 URL(Uniform Resource Locator)은 네트워크상에 존재하는 자원을 찾아가기 위한정보입니다. URL은 다음과 같은 형식으로 표현합니다.

프로토콜 - 서버주소 - 포트번호 - URI

**프로토콜**
프로토콜은 서버와 통신하기위한 규약으로 서버마다 사용하는 프로토콜이 정해져있다. 
예를들면 아래와같다.
* 웹서버 = HTTP://
* 오라클 DBMS = jdbc:oracle:thin:@

**서버 주소**
네트워크상에서 연결된 컴퓨터를 찾아가기 위한 정보로서 IP주소 또는 도메인 이름으로 표현한다. 서버가 동작하고 있는 컴퓨터 정보입니다.

**포트 번호**
URL에서 서버 주소를 이용해 컴퓨터를 찾았다면 포트번호는 컴퓨터에서 동작하고 있는 서버로 접속하기 위한정보입니다. 포트번호는 0~65,535번까지 사용할 수 있으며, 0~1,023 사이의 번호는 well-known port로써 이미 사용이 정의되어 있다. 예를들어 웹서버 포트는 80포트이며 마일 URL에서 HTTP프로토콜로 접속시 포트번호를 생략하면 자동으로 80포트로 인식한다. 80이외에는 직접 포트를 입력해줘야합니다.

**URI**
URI(Uniform Resource Identifier)는 서버에서 서비스하는 서버의 자원 정보입니다. URL에서 포트 번호  다음부터가 URI입니다. 만일 다음과 같은 URL있다고 가정해보겠습니다.

http://www.mysite.com:80/edu/index.html

먼저 www.mysite.com을 이용해 컴퓨터를 찾아고, 다음 정보인 80을 이용해 서버를 찾아옵니다. 웹서버를 찾아오기까지 www.mysite.com:80 정보를 사용하고, URI 정보로 웹서버에서 클라이언트가 요청한 문서를 찾아 실행한 후 결과를 또는 그파일 자체를 클라이언트에 응답합니다.


**헤더**
요청 줄 다음에는 헤더가 위치합니다. header는 general-header, request-header, entity-header 3가지로 분류할 수 있으며, 클라이언트의 요처에 따라 필요한 헤더만 사용됩니다. 헤더에는 name:content의 형식으로 정보들이 표현되며 content 부분의 값들은 공백이나 탭으로 구분된다. 다음은 요청정보 헤더값이다.

| name            | content                                                                       |
| --------------- | ----------------------------------------------------------------------------- |
| Accept          | text/html, application/xhtml+xml, application/xml:q=0.9, image/webp.*/*;q=0.8 |
| Accept-Encoding | gzip, deflate, sdch                                                           |
| Accept-Language | ko-KR, ko : q=0.8, en-US; q=0.6, en:q=0.4                                     |
| User-Agent      |Mozilla / 5.0(Widows NT 6.1; WOW64 AppleWebKit/537.36(KHTML, like Gecko) Chrome/51.0.2704.103 safari/537.36|
| Cache-Control   |No-cache, no-store, max-age|

**Accept**
클라이언트가 인식하여 처리할 수 있는 파일 타입을 명시합니다. 여러 개의 파일 타입은 쉼표로 구분하여 나열한다.

**Accept-Encoding**
compress 또는 gzip과 같은 웹 클라이언트가 받아들일 수 있는 인코딩 방식을 지정합니다. 여러개의 인코딩 방식을 쉼표(,)로 구분하여 나열합니다. 만약 인코딩 형태를 지정하지 않으면 클라이언트에 어떤 형태도 받아들여지지 않습니다.

**Accept-Language**
클라이언트가 지원하는 언어를 지정합니다.


**User-Agent**
클라이언트가 사용하는 웹브라우저에 대한 정보를 보여줍니다. 서버 쪽에서는 User-Agent 정보를 보고 일반 웹페이지와 모바일 웹페이지로 자동 분기합니다.

**Cache-Control**
HTTP 캐시는 클라이언트가 서버에 요청하여 응답받은 서비스 결과를 클라이언트 쪽에 저장했다가 사용자로부터 같은 서비스 요청이 들어오면 이전에 저장된 처리결과를 보여주는 것을 말ㄹ합니다. 캐시는 클라이언트와 서버사이에 발생하는 작업을 생략함으로써 트래픽을 줄이고, 클라이언트는 응답을 빠르게 받을 수 있는 장점이 있습니다. Cache-Control에 다음과 같은 값을 설정할 수 있습니다.

* no-cache : 캐시안함
* no-store : 신속히 넘긴후 정보 제거
* max-age = seconds : 지정된 시간보다 오래된 데이터는 캐시 안함
* max-stale = seconds : 지정된 시간이 아직도 되지않은 만료된 데이터를 보냄
* min-fresh = seconds : 지정된 시간 이후의 변경된 새로운 데이터만 보냄
* only-if-cached : 새로운 데이터를 검색하지 않고 캐시에 있는 데이터만 반환




#### HTTP 응답정보

웹서버에서 클라이언트로 보내지는 응답 정보 메시지의 구조는 다음과 같습니다. 

![HTTP-응답정보](/assets/HTTP-응답정보.jpg)

위에서 보여지는 HTTP 상태줄은 HTTP버전, 상태코드, 상태코드 설명으로 구성된다. 
HTTP 버전 : 서버가 응답하기 위해 사용하는 HTTP 버전 정보이다.
상태코드 : 요청한 처리 결과를 숫자 세자리로 나타낸다.
상태 코드 설명 : 처리결과를 이해하기 쉬운 텍스트로 설명해준다.

**헤더**
상태 줄 다음에 헤더가 위치하는데요. 클라이언트 서비스 요청에 대한 실행결과를 웹 클라이언트가 올바르게 처리할 수 있게 하기 위한 정보들로 구성됩니다. 다음은 응답정 헤더의 필드이름과 값들입니다.


|name|content|
|-|-|
|Cache-Control|public, private, no-cache, no-transform, must-revalidate, proxy-revaildate|
|Connection |close |
|Content-Encoding | gizp |
|Content-Type |text/html; charset = UTF-8 |
|Date | Fri, 15 Jul 2016 23:06:23 GMT |
|Server |nginx |

**Cache-Control**
HTTP1.1 버전에서 지원하는 헤더로서 응답결과를 캐시에 저장할지에 관한 내용을 나타냅니다. HTTP 1.0 버전에서는 Pramgma이름으로 설정됩니다. 클라이언트가 요청할 때마다 페이지의 내용이 자주 바뀌지 않는 정적인 페이지일때는 적용하게 좋고 만약 요청때마다 바뀌는 화면이라면 적용하지 않는 것이 좋습니다. 캐시는 다음과 같은 값으로 적용할 수 있습니다.

|타입|설명|
|-|-|
|public|어떠한 캐시라도 캐시할 수 있음|
|private |공유된 캐시는 캐시하지 않음 |
|no-cache | 캐시하지 않음 |
|no-transform |데이터를 변환하지 않음 |
|must-revalidate | 클라이언트는 데이터를 재확인해야함 |
|proxy-revalidate | 개인적인 클라이언트 캐시를 제외하고 데이터를 재확인해야함. |

**Connection**
연결을 위해 지정하는 정보로서 close 연결은 클라이언트나 서버 둘중 하나가 연결을해제하기 원한 다는것을 알립니다.

**Content-Encoding**
메시지를 전송할 때 사용할 인코딩 체계(scheme)를 지정합니다. 값으로는 gzip 또는 x-gizp과 compress 또는 x-compress를 사용할 수 있습니다.

**Content-Type**
클라이언트가 요청한 메시지의 데이터 포맷으로서 서버도 같은 데이터타입으로 처리하여 응답해야합니다.

**Date**
웹서버가 클라이언트에 응답한 날짜와 시간을 표시합니다.

**Server**
클라이언트의 서비스 요청을 받아서 서비스를 처리한 서버의 이름과 버전 정보를 나타냅니다.



서블릿 인스턴스의 스레드를 생성하는 게 아니었다.

요청이 들어오면 WAS(Web Application Server)에서 스레드를 생성하여
서블릿 인스턴스의 service() 메서드를 실행한다.

