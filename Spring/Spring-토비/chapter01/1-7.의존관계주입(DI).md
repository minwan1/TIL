### 1.7 의존과계 주입(DI)
#### 1.7.1 제어의 역전과 의존관계 주입
여기에서 한가지 짚고 넘어갈 것은 IoC라는 용어인데, IoC가 매우 느슨하게 정의돼서 폭넓게 사용되는 용어라는것이다. 때문에 스프링을 IoC 컨테이너라고만 해서는 스프링이 제공하는 기능의 특징을 명확하게 설명하지 못했다. 그래서 나온말이 IoC방식을 핵심을 짚어주는 의존관계 주입(DI)이다. 스프링의 IoC 기능의 대표적인 동작원리는 주로 의존관계 주입이라고 불린다. 스프링이 여타 프레임워크와 차별화돼서 제공해주는 기능은 의존관계 주입이라는 새로운 용어를 사용할 때 분명하게 드러난다. 초기에는 주로 IoC 컨테이너라고 불리던 스프링이 지금은 의존관계 주입 컨테이너 또는 그영문약자를 써서 DI컨테이너라고 더 많이 불리고 있다.

#### 1.7.2 런타임 의존관계 설정
##### 의존관계
두 개의 클래스 또는 모듈이 의존관계에 있다고 말할 때는 항상 방향성을 부여해줘야 한다. 즉 누가 누구에게 의존하는 관계 있다는 식어야한다. A클래스가 B에 의존하고 있을때 B가 변동사항이 있으면 A에 영향을 미치게된다. 하지만 A가 변경된다고해서 B는 영향 받지 않는다.

##### UserDao의 의존관계
![](https://i.imgur.com/dVxCl6m.png)
위 그림은 UserDao가 ConnectionMaker에 의존하고 있는 형태이다. ConnectionMaker인터페이스가 변한다면 그영향은 UserDao가 받을 것이다. 하지만 ConnectionMaker의 구현체인 DConnectionMaker등이 바뀌거나 내부적으로 메소드가 변화가 생겨도 UserDao에 영향을 주지 않는다. 이렇게 인터ㅔ이스대해서만 의존관계를 만들어두면 인터페이스를 구현 클래스와의 관계는 느슨해지면서 변환에 영향을 덜 받는 상태가 된다. 인터페이스를 통해 의존관계를 제한해주면 그만큼 변경에서 자유로워지는 셈이다.
그런데 모델이나 코드에서 클래스와 인터페이스를 통해 드러나는 의존관계말고, 런타임시에 오브젝트 사이에서 만들어지는 의존관계도 있다. 의존과계 또는 오브젝트 의존 관계인데, 설계 시점의 의존관계가 실체화된 것이라고 볼 수 있다. 런타임 의존관계는 모델링 시점의 의존관계와는 성격이 분명히 다르다.
인터페이스를 통해 설계 시점에 느슨한 의존관계를 갖는 경우에는 UserDao의 오브젝트가 런타임 시에 사용할 오브젝트가 어떤 클래스로 만든것인지 미리 알 수 가없다. 프로그램이 시작되고 UserDao 오브젝트가 만들어지고 나서 런타임 시에 의존관계를 맺는 대상, 즉 실제 사용대상인 오브젝트를 의존 오브젝트라고 한다.

의존관계 주입은 이렇게 구체적인 의존 오브젝트와 그것을 사용할 주체, 보통 클라이언트라고 부르는 오브젝트를 런타임시에 연결해주는 작업을 말한다. UserDao는 ConnectionMaker 인터페이스라는 매우 단순한 조건만 만족하면 어떤 클래스로부터 만들어졌든 상관없이 오브젝트를 받아 들이고 사용한다.

```
의존관계주입이란
-클래스 모델(UML)이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해서는 인터페이스에만 의존하고 있어야한다.
-런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제 3의 존재가 결정한다.
-의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부주에서 제공(주입)해줌으로써 만들어진다.
```
의존관계 주입의 핵심은 설계 시점에는 알지 못했던 두 오브젝트의 관계를 맺도록 도와주는 제 3의 존재가 있다는것이다. DI에서 말하는 제 3의 존재는 바로 관계설정 책임을 가진 클래스 라고 볼 수 있다. DaoFactory,ApplicationContext,Ioc컨테이너등이 모두 외부에서 오브젝트 사이의 런타임 관계를 맺어주는 책임을 지닌 제 3의 존재라고 볼 수 있다.

##### UserDao의 의존관계 주입
다시 처음에 봤던 UserDao 에 적용된 의존관계 주입 기술을 다시 살펴보자. 인터페이스를 사이에 두고 UserDao와 ConnectionMaker구현클래스간에 의존관계를 느슨하게 만들긴 했지만, 마지막으로 남은 문제가 있었는데 아래소스와같이 UserDao가 사용할 구체적인 클래스를 알고 있어야 하는점이다.

```java
public UserDao(){
  connectionMaker = new DConnectionMaker();
}

```
이코드는 이미 설계 시점에 구체적인 런타임 의존관계 오브젝트를 알고 있다. 즉 DConnectionMaker오브젝트를 사용하겠다는 것 까지 UserDao가 결정하고 관리하고 있는셈이다.

이코드의 문제는 이미 런타임시의 의존관계가 코드 속에 미리 다 결정되어있다는 것이다. 그래서 Ioc방식을 써서 UserDao로부터 런타임 의존관계를 드러내는 코드를 제거하고, 제 3의 존재에 런타임 의존관계 결정을 권한을 위함하는것이다. 그래서 최종적으로 만들어졌던것이 DaoFactory이다. DaoFactory는 런타임시점에 UserDao가 사용할 ConnectionMaker타입의 오브젝트를 결정하고 이를 생성한후에 UserDao의 생성자 파라미터로 주입해줌으로써 런타임 의존관계를 맺게 해준다. 이렇게 런타임시 주입의 기능을 수행함으로써 DaoFactory를 DI/IoC컨테이너라고도 한다.

DI컨테이너느 자신이 결정한 의존관계를 맺어줄 클래스의 오브젝트를 만들고 이생성자를 파라미터로 오브젝트의 레퍼런스를 전달해준다. 그럼 아래 소스같이 생성자 파라미터를 통해 전달받은 런타임 의존관계를 갖는 오브젝트는 인스턴스 변수에 저장 해둔다.

```java
public class UserDao{

  private ConnectionMaker connectionMaker;

  public UserDao(ConnectionMaker connectionMaker){
    this.connectionMaker = connectionMaker;
  }

}
```
이렇게 해서 두 개의 오브젝트 간에 런타임 의존관계 만들어졌다. UserDao 오브젝트는 이제 생성자를 통해 주입받은 DConnectionMaker 오브젝트를 언제든 사용하면 된다. DI는 자신이 사용할 오브젝트에 대한 선택권과 생성 제어권을 외부로 넘기고 자신은 런타임시에 수동적로 주입받은 오브젝트를 사용한다는 점에서 IoC의 개념에 잘 들어 맞는다. 스프링 컨테이너의 IoC는 주로 의존관계 주입 또는 DI라는 데 초점이 맞춰져 있다. 그래서 스프링을 IoC컨테이너 외에도 DI컨테이너 또는 DI프레임워크라 한다.



#### 1.7.3 의존관계 검색과 주입
스프링이 제공하는 IoC방법에서 오브젝트를 주입하는 방법 의존성 주입만 있는것은 아니다. 의존 관계를 맺는 방법이 외부로부터의 주입이 아니라 스스로 검색을 이용하는 의존관계 검색이 있다. 의존관계 검색은 자신이 필요로 하는 의존 오브젝트를 능동적으로 찾는다. 물론 자신이 어떤 클래스의 오브젝트를 이용할지는 결정하지 않는다. 의존관계 검색은 런타임 시 의존관계를 맺을 오브젝트를 결정하는 것과 오브젝트의 생성작업은 외부 컨테이너에게 맡기지만, 이를 가져올때는 메소드나 생성자를 통한 파라미터 전달이 아닌 아래 소스와같이 직접 컨테이너에게 요청하는 방식이다.

```java
public UserDao(){
  DaoFactory daoFactory = new DaoFactory();
  this.connectionMaker = daoFactory.connectionMaker();
}
```
위와같이 생성해도 여전히 자신이 어떤 ConnectionMaker 오브젝트를 사용할지 미리 알지 못한다. 여전히 코드의 의존대상은 ConnectionMaker인터페이스이기 때문이다. 런타임시에 DaoFactory가 만들어서 돌려주는 오브젝트와 다이내믹하게 런타임 의존관계를 맺는다. 따라서 IoC개념을 잘 따르고 있으며, 그혜택을 받는 코드다. 하지만 적용방법은 외부로부터의 주입이 아니라 스스로 IoC 컨테이너인 DaoFactory에게 요청하는것이다.
위소스의 작업을 일반화한 스프링의 애플리케이션 컨텍스트라면 미리 정해놓은 이름을 전달해서 그 이름에 해당하는 오브젝트를 찾게 된다. 따라서 이를 일종의 검색이라고 볼 수 있다. 또한 그 대상이 런타임 의존관계를 가질 오브젝트이므로 의존관계 검색이라고 부르는 것이다.
스프링의 IoC 컨테이너인 애플리케이션 컨텍스트는 getBean이라는 메소드를 제공한다. 바로 이메소드가 의존관계를 검색에 사용되는것이다. 이것은 아래의 예제와같이 사용 할 수 있다.
```java
public UserDao(){
  AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.clas);

  this.connectionMaker = context.getBean("connectionMaker",ConnectionMaker.class);
}
```

의존관계 검색은 기존 의존관계 주입의 거의 모든 장점을 갖고 있다. 하지만 코드면에서 좀 더 의존관계주입이 단순하고 깔끔하다. 의존관계 검색은 코드안에 오브젝트 팩토리 클래스나 스프링 API가 나타난다. 검색 방식을 이용하면 그안에서 컨텍스트를 만들고, 호출하고등의 불필요한 소스를 넣어줘야하기 때문이다. 따라서 대개는 의존관계주입방식을 사용하는것이 낫다.
```java

public class UserDaoTest{
  public static void main(String[] args) throws ClassNotFoundException,SQLException{
    ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);
    UserDao dao = context.getBean("userDao",UserDao.class);
    ...
  }

}

```
하지만 위에 소스처럼 static 메소드인 Main같은경우에는 DI를 이용해 오브젝트를 주입받을 방법이 없기 때문이다. 이러한경우 말고는 의존성주입을 받아 사용하는게 소스면에서 훨씬 깔끔하다.

#### 1.7.4 의존관계 주입의 응용
##### 부가기능 추가
다음 이런경우를 한번 생각해보자. DAO가 DB를 얼마나 많이 연결해서 사용하는지 파악하고 싶다. DB연결횟수를 카운팅하기 위해 무식한 방법으로 모든 DAO의 makeConnection() 메소드를 호출하는 부분에 새로 추가한 카운터를 증가시키는 코드를 넣는것은 엄청난 낭비이고 노가다다.  그리고 무엇보다 DAO코드를 손대는것은 지금까지 피하려고했던 행동을 하는 것이다.
DI 컨테이너에서라면 아주 간단한 방법으로 해결가능하다. DAO와 DB 커넥션을 만드는 오브젝트 사이에 열결횟수를 카운팅하는 오브젝트를 하나 더 추가하는 것이다.

```java
public class CountingConnectionMaker implements ConnectionMaker{
  int counter = 0;
  private ConnectionMaker realConnectionMaker;

  public CountingConnectionMaker realConnectionMaker(ConnectionMaker realConnectionMaker){
    this.realConnectionMaker = realConnectionMaker;
  }

  public Connection makeConnection() throws ClassNotFoundException,SQLException{
    this.counter++;
    return realConnectionMaker.makeConnection();
  }

  public int getCounter(){
    return this.counter;
  }
}
```
CountingConnectionMaker 클래스는 ConnectionMaker 인터페이스를 구현했지만 내부에서 직접 DB커넥션을 만들지 않는다. 대신 DAO가 DB커넥션을 가져올 때마다 호출하는 makeConnection()에서 DB연결횟수 카운터를 증가시킨다.CountingConnectionMaker는 자신의 관심사인 DB 연결횟수 카운팅 작업을 마치면 실제 DB 커넥션을 만들어주는 realConnectionMaker에 저장된 ConnectionMaker타입 오브젝트의 makeConnection()호출해서 그 결과를 DAO에 돌려준다.

생성자를 보면 ConnectionConnectionMaker도 DI를 받는것을 알 수 있다. UserDao는 ConnectionMaker의 인터페이스에만 의존하고 있기 때문에 ConnectionMaker 를 구현하고있는 어떤 구현체라도 DI가 가능하다. 그래서 DI받는 오브젝트를 DConnection오브젝트를 대신 CountingConnectionMaker를 받은것이다. 그리고 그 CountingConnectionMaker는 DConnectionMaker를 의존주입을 받은것이다.
![](https://i.imgur.com/UCSKxiu.png)
이렇게해서 CountingConnectionMaker 재구성된 새로운 런타임 의존관계는 위 그림과 같다. 우의 그림을 코드라바꾸면 아래와같이 만들 수 있다.
```java
@Configuration
public class CountingDaoFactory{
  @Bean
  public UserDao userDao{
    return new UserDao(ConnectionMaker());
  }

  @Bean
  public ConnectionMaker connectionMaker(){
    return new CountingConnectionMaker(realConnectionMaker());
  }

  @Bean
  public ConnectionMaker realConnectionMaker(){
    return new DConnectionMaker();
  }
}
```

이제 커넥션 카운팅을 위한 실행 코드를 만들어보자. 기본적으로 UserDaoTest와 같지만 설정요 클래스를 CountingDaoFactory로 변경해줘야한다. 그리고 CountingConnectionMaker빈을 가져온다. 설정정보에 지정된 이름과 타입만 알면 특정 빈을 가져 얼 수 있으니 CoutingConnectionMaker 오브젝트를 가져오는 건 간단하다.

```java

public class UserDaoConnectionCountingTest{
  public static void main(String[] args) throws ClassNotFoundException,SQLException{
    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(CountingDaoFactory.class);
    UserDao dao = context.getBean("userDao",UserDao.class);

    //
    //DAO 사용코드
    //

    CountingConnectionMaker ccm = context.getBean("connectionMaker",CountingConnectionMaker.class);
    System.out.println("Connection counter :" + ccm.getCounter());
  }
}
```
이렇게 함으로써 DBConnection 분석이 끝나면 다시 CountingDaoFactory 설정 클래스를 DaoFactory로 변경하거나 connectionMaker()메소드를 수정하는 것만으로 DAO의 런터암 의존관계는 이정상태로 복구된다.

#### 1.7.5 메소드를 이용한 의존관계 주입
간단하게 설명하자면 스프링에서 의존섭을 주입하는 방법은 생성자를 이용하는 방법뿐만 아니라 아래와 같이 setter아니면 직접 메소드를 정의해서 의존성을 주입하는 방법이있다.
```java
public class UserDao{
  private ConnectionMaker connectionMaker;

  public void setConnectionMker(ConnectionMaker connectionMaker){
    this.connectionMaker = connectionMaker;
  }
}
```
```java
@Bean
public UserDao userDao(){
  UserDao userDao = new UserDao();
  userDao.setConnectionMaker(connectionMaker());
  return userDao;
}
```
단지 의존관계를 주입하는 시점과 방법이 달라졌을 뿐 결과는 동일하다.
