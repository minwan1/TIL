## 1장 오브젝트와 의존관계
스프링은 자바 엔터프라이즈 기술의 혼란속에서 잃어버렸던 객체지향 기술의 진정한 가치를 회복시키고 폭넓은 혜택을 누릴수있도록하는것이 스프링 철학이다. 그래서 스프링에서 관심을 많이두는것은 오브젝트의 생명주기이다. 오브젝트 생명관리를 통해 재활용 가능한 설계방법의 디자인패턴, 좀 더 깔끔한 소스구조이다.

### 1.1 초난감 DAO
JDBC를 이용한 User CURD를 다루는 UserDAO생성.
### 1.2 DAO 분리

#### 1.2.1 커넥션만들기의 추출
항상 미래를 내다보고 설계해야한다. 중복된 코드가 무엇인지에대해 생각하여야한다. 초난감 DAO에서 가장 먼저 할일은 커넥션을 가져오는 중복된 코드를 분리하는 것이다. 중복된 부분을 getConnetion 메소드로 빼서 연결이 필요할때는 그메소드를 호출하는것이다.
```java
public User get(String id)  throws ClassNotFoundException,SQLException{
  Connection c = getConnetion();
}

private Connection getConnection() throws ClassNotFoundException,SQLException{
  class.forName("com.mysql.jdbc.Driver");
  Connection C = DriverManager.getConnection("jdbc:mysql://localhost/springbook","spring",book);
  return c
}
```
위에 getConnection메소드는 관심의 종류에 따라 코드를 구밴 해놓았기 때문에 한가지관심 예를들어 데이터베이스의 종류를 바꾼다든지 그런 문제에서 하나의 메소드만 변경하게 되면 손쉽게 데이터 베이스를 바꿀수 있게 해준다.위 코드로 인하여 다른 get메소드같은데에는 영향을 끼치지 않는다.
위에 초난감 DAO를 리팩토링 했는데 리팩토링은 객체지향 개발자라면 반드시 익혀야하는 기법이다.

#### 1.2.2 DB커넥션 만들기의 독립
이번에는 좀더 변화를 반기는 DAO를 만들것이다.
##### 상속을 통한 확장
![](https://i.imgur.com/Ux1nXhz.png)
위그림과 같이 UserDao를 추상클래스로 선언 하면 좀더 확장성 있는 소스가 될 것이다. 이렇게 선언하게되면 추상클래스에 add와 get만 메소드를 구현하고 getConnection은 깡통메소드로 나두게되면 NUserDao,DUserDao에서 getConnection만 구현하게되면 2개의 각기 다른 디비를 붙일 수 있다. 이렇든 UserDao와같은 슈퍼클래스는 기본적인 로직의 흐름(커넥션가져오기,sql생성,실행,반환)만들고 서브클래스는 메소드를 구현하는 패턴을 템플릿 메소드 패턴이라고 한다. 템플릿 메소드 패턴은 스프링에서 애용하는 패턴이다.



### 1.3 DAO의 확장
;; 정리한게 다날라가버렸다.(간단하게 정리해야겟다)
#### 1.3.1 클래스의분리
Connection 생성 부분을 클래스로 분리한다. 하지만 여전히 UserDao 에서 클래스를 생성해야하기때문에 UserDao는 ConnectionMaker클래스에 의존적이다.
#### 1.3.2 인터페이스의 도입
인터페이스를 도입했지만 여전히 자바에서 인터페이스를 통해 객체를 생성할때 아래와같이 new DConnectionMaker(); 선언을 해줘야하기떄문에 근본적인 문제가 해결되지않는다.
```java
public UserDao(){
  connectionMaker = new DConnectionMaker();
}
```
#### 1.3.3 관계설정 책임의 분리
![](https://i.imgur.com/ZBKuVCa.png)
그래서 이러한 근본적인 문제를 해결하기 위해서는 인터페이스를 통해서 처음부터 관계를 설정해주면된다. 아래와같이.

```java
public interface ConnectionMaker {
    public Connection makeConnection() throws ClassNotFoundException, SQLException;
}

public class DConnectionMaker implements ConnectionMaker {
    public Connection makeConnection() throws ClassNotFoundException, SQLException {
        // D 사의 독자적인 방법으로 Connection 을 생성하는 코드
    }
}
public class UserDao {
    private ConnectionMaker connectionMaker; ㅡ> 인터페이스를 통해 오브젝트에 접근, so 구체적 클래스 정보가 필요 없다.

    public UserDao(ConnectionMaker connectionMaker){
        this.connectionMaker = connectionMaker;  
    }

    public void add(User user) throws ClassNotFoundException, SQLException {
        Connection c = connectionMaker.makeConnection();
      ㅡ> 인터페이스에 정의된 메소드를 사용하므로 클래스가 바뀐다고 메소드 이름이 변경 되지 않는다.
    }

    public user get(String id) throws ClassNotFoundException, SQLException {
        Connection c = connectionMaker.makeConnection();
    }
}

```

UserDaoTest
```java
public class UserDaoTest{
    public static void main(String[] args) throws ClassNotFoundException, SQLException {
        ConnectionMaker connectionMaker = new DConnectionMaker();
        // UserDao가 사용할 ConnectionMaker 구현 클래스를 결정하고 오브젝트를 만든다.

        UserDao dao = new UserDao(connectionMaker);
        // 1. UserDao 생성
        // 2. 사용할 ConnectionMaker 타입의 오브젝트 제공, 결국 두 오브젝트 사이의 의존관계 설정
    }
}
```

최종적으로 UserDaoTest와같이 UserDao를 즉 3자 호출하는곳에서 의존성 주입을하게되면 아래와같이 불필요한 의존관계를 끊을 수 있게된다. 이렇게되면 D사,N사에서 UserDao를 구현할필요없이 N사와 D사는 ConnectionMaker인터페이스의 Connection만 구현해주게되면 N사와 D사는 UserDao클래스를 신경쓸 필요가 없게 된다.
![](https://i.imgur.com/gX6THnw.png)

#### 1.3.4 원칙과 패턴

##### 개방 폐쇄원칙
개방 폐쇄 원칙은 깔끔한 설계를 위해 적용 가능한 객체지향 설계 원칙 중의 하나다. 클래스나 모듈은 확장에는 열려 있어야하고 변경에는 닫혀 있어야한다고 할 수 있다. UserDao는 DB연결 방법이라는 기능을 확장하는데는 열려있다. UserDao에는 전혀 영향을 주지 않고도 얼마든지 확장 가능하다. 잘설계된 객체지향 클래스의 구조를 살펴보면 바로 이 개방 폐쇄 원칙을 아주 잘 지키고 있다. 인터페이스를 사용해 확장 기능을 저으이한 대부분의 API는 바로 개방 폐쇄 원칙을 잘 따르고 있다고 볼 수 있다.


##### 높은 응집도와 낮은 결합도

높은 응집도 (같은 기능끼리 모여있다는것)
응집도가 높다는것은 하나의 모듈,클래스가 하나의 채김 또는 관심사에만 집중되어 있다는 뜻, 하나의 모듈에서만 변경이 많이 일어나면 다른 모듈은 변경이 필요가 없을때를 말한다. 하나의 클래스에 여러가지 관심사가 모여있다면 그 관심사 하나가 변경되면 다른 영향을 미치짖 않는지 확인해야하는 이중의 부담이 생긴다. 예를들어 기존의 NConnectionMaker를 개선해서 2.0을 만들었다해보자. 그렇게되면 NConnectionMaker를 테스트하기위해서 모든 DAO를 테스트할필요는없다. 높은 응집도때문에 그냥 NConnectionMaker만 테스트해도 충분하다. ConnectionMaker를 분리해서 높은 응집도를 가지고있기 때문이다.

낮은 결합도
낮은 결합도는 높은 응집도 보다 더 민감한 원칙이다. 책임과 관심사가 다른 오브젝트 또는 모듈과는 낮은 결합도, 즉 느슨하게 연결된 형태를 유지하는것이 바람직하다. 결합도가 낮아지면 변화에 대응하느 속도가 높아지고, 구성이 깔끔해진다. 또한 확장하기에도 매우 편리하다. 예를들면 위에서 보여준 예제처럼 인터페이스를 통한 ConnectionMaker구현이 있을 수 있다.

전략패턴
개선한 UserDaoTest - UserDao - ConnectionMaker 구조를 디자인 패턴의 시각으로 보면 전략 패턴에 해당한다고 볼 수 있다. 전략패턴은 디자인 패턴의 꽃이라고 불릴만큼 다양하게 자주 사용되는 패턴이다. 개방 폐쇄 원칙의 실현에도 가장 잘 들어 맞는 패턴이라고 볼 수 있다. 전략 패턴은 자신의 기능 Context에서,필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용 할 수 있게 하는 디자인 패턴이다.
UserDao는 전략패턴의 컨텍스트에 해당한다. 컨텍스트는 자신의 기능을 수행하는데 필요한 기능 중에서 변경 가능한, DB 연결 방식이라는 알고리즘을 ConnectionMaker라는 인터페이스로 정의하고, 이를 구현한 클래스, 즉 전략을 바꿔가면서 사용할 수 있게 분리했다.
전략패턴은 컨텍스트(UserDao)를 사용하는 클라이언트(UserDaoTest)는 컨텍스트가 사용할 전략 (ConnectionMaker를 구현한 클래스, 예 DConnectionMaker)을 컨텍스트의 생성자등을 통해 제공해주는게 일반적이다.


### 1.4 제어의 역전(IoC)

#### 1.4.1 오브젝트 팩토리

UserDaoTest는 기존에 UserDao가 직접 담당하던 기능, 즉 어떤 ConnectionMaker구현 클래스를 사용할지를 결정하는 기능을 엉겁결에 떠 맡았다. UserDao가 ConnectionMaker인터페이스를 구현한 특정 클래스로부터 완벽하게 독립할 수 있도록 UserDao의 클라이언트인 UserDaoTest가 그 수고를 담당하게 된 것이다.
그런데 처음목적은 UserDaoTest는 UserDao의 기능이 잘 동작하는지를 테스트하려고 만든 것이다. 그런데 지금 또다른 책임까지 떠 맡고 있으니 UserDaoTest는 2개의 관심사를 가지고 있는것이다. 그러므로 두개의 관심사를 분리해줘야한다.

##### 팩토리
팩토리 클래스의 역할은 객체의 생성방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 것이다. 팩토리 클래스의 역할을 맡을 클래스는 DaoFactory이다. DaoFactory는 UserDaoTest에서는 DaoFactory에 요청해서 미리 만들어진 UserDao오브젝트를 가져와 사용하게 만든다.


```java

public class DaoFactory{
  public UserDao userDao(){
    //팩토리메소는 UserDao탕ㅂ의 오브젝트를 어떻게 만들고 어떻게 준비시킬지 결정한다.
    ConnectionMaker connectionMaker = new DConnectionMaker();
    UserDao userDao = new UserDao(connectionMaker);

    return userDao;
  }
}

```
아래와같이 이제 UserDaoTest는 더이상 UserDao가 어떻게 생성되는지 신경쓰지 않고 테스트하는것에만 집중할 수 있게된다.

```java
public class UserDaoTest{
  public static void main(String[] args) throws ClassNotFoundException,SQLException{
    UserDao dao = new DaoFactory.userDao();
    ...
  }
}

```

##### 설계도로서의 팩토리
![](https://i.imgur.com/YZ4jvF2.png)
그림과 같이 UserDaoTest는 DaoFactory를통해 DConnectionMaker를 주입받아 사용하게된다.

#### 1.4.2 오브젝트 팩토리의 활용
만약 추가적인 Dao들이 추가된다고 생각해보자. 그러면 아래와같이 반복되는 코드가 발생하게된다.
```java
public class DaoFactory{


  public UserDao userDao(){
    return new UserDao(new DConnectionMaker();)
  }

  public AccountDao userDao(){
    return new UserDao(new DConnectionMaker();)
  }

  ...

}
```
위의 문제를 해결할려면 ConnectionMaker를생성하는 아래의소스와같이 공통으로 뽑아내는 방법이있다.

```java

public class DaoFactory{


  public UserDao userDao(){
    return new UserDao(new DConnectionMaker();)
  }

  public AccountDao userDao(){
    return new UserDao(new DConnectionMaker();)
  }

  ...

  public ConnectionMaker connectionMaker(){
    return new DConnectionMaker();
  }

}
```
위와같이 소스를 변경하게되면 ConnectionMaker부분만 수정하게되면 Dao팩토리 메소드가 많아져도 ConnectionMaker의 메소드만 변경하게되면 모든 커넥션마커의 기능들이 수정되기때문에 시간을 절약할수 있게 된다.

#### 1.4.2 제어권의 이전을 통한 제어관계 역전
일반적으로 프로그램의 흐름은 main() 메소드와 같이 프로그램이 시작되는 지점에서 다음에 사용할 오브젝트를 결정하고 결정한 오브젝트를 생성하고, 만들어진 오브젝트를 사용한다. 언제 어떻게 오브젝트를 만들지를 스스로 관장한다. 모든 종류의 작업을 사용하는 쪽에서 제어하는 구조이다. 제어의 역전은 이런 제어 흐름의 개념을 거꾸로 뒤집는 것이다. 제어의 역전에서는 모든 제어의 권한을 자신이 아닌 다른 대상에게 위임한다.
제어의 역전 개념은 이미 서블릿에서도 사용되고있다. 서블릿에 대한 제어권한을 가진 컨테이너가 적절한 시점에 서블릿 클래스의 오브젝트를 만들고 그안의 메소드를 호출한다. 이렇게 서블릿이나,jsp,ejb에서는 간단한 방식으로 제어의 역전 개념이 적용되어 있다.


### 1.5 Spring IoC
스프링의 핵심을 담당하는 건 바로 빈팩토리, 또는 ApplicationContext라고 불리는 것이다. 이것은 우리가 만든 DaoFactory가 하는 일을 좀더 일반화한 것이라고 할 수 잇다

#### 1.5.1 제어권의 이전을 통한 제어관계 역전
스프링에서는 스프링이 제어권을 가지고 직접 만들고 관곌ㄹ 부여하는 오브젝트를 빈이라고 부른다. 스프링에서 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트를 빈팩토리라고 한다. 보통 빈팩토리보다는 이를 좀더 확장한 ApplicationContext를 주로 사용한다.
ApplicationContext는 별도의 정보를 참고해서 빈의 생성, 관계설정등의 제어 작업을 총괄한다. DaoFactory에서는 어떤 클래스의 오브젝트를 생성할지 어떻게 연결할것인지에 대해 설정을 해줬었다. 하지만 ApplicationContext는 직접 이런정보를 담지 않고 별도로 설정정보를 담고 있는 자바 @Configuration 설정되어져 있는 자바클래스의 정보를 가져와 이를 활용하는 범용적인 Ioc 엔진이라고 할 수 있다.

##### DaoFactory를 사용하는 ApplicationContext
DaoFactory를 스프링의 빈팩토리(ApplicationContext)가 사용할수있도록 설정 정보를 만들 것이다. 먼저 빈 팩토리를 위한 오브젝트 설정을 담당하는 클래스라고 인식할수 있도록 @Configuration 이라는 어노테이션을 추가한다. 그리고 오브젝트를 만들어주는 메소드에는 @Bean 이라는 어노테이션을 추가한다.

```java

@Configuration // 애플리케이션 컨텍스트 또는 빈 팩토리가 사용할 설정정보라는 표시
public class DaoFactory{

  @Bean // 오브젝트를 새엉을 담당하는 IoC용 메소드라는 표시
  public UserDao userDao(){
    return new UserDao(connectionMaker());
  }

  @Bean
  public ConnectionMaker connectionMaker(){
    return new DConnectionMaker();
  }
}

```
이제 아래와같이 준비된 ApplicationContext의 getBean()이라는 메소드를 이용해서 UserDao의 오브젝트를 가져올 수 있다.

```java

public class UserDaoTest{
  public static void main(String[] args) throws ClassNotFoundException,SQLException{
    ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);
    UserDao dao = context.getBean("userDao",UserDao.class);
    ...
  }

}

```
context.getBean("userDao",UserDao.class);의 userDao는 메소드의 이름이다.어떻게 메소드의 이름을 설정하느냐에따라 그부분을 변경해주면 된다.


#### 1.5.2 ApplicationContext의 동작 방식
스프링에서 ApplicationContext를 IoC컨테이너라고 하기도하고 간단히 스프링 컨테이너라고도 한다. @Configuration이 붙은 DaoFactory는 ApplicationContext가 활용하는 IoC설정정보다. 내부적으로 애플리케이션 컨텍스가 DaoFactory의 userDao() 메소드를 호출해서 오브젝트를 가져온 것을 클라이언트가 getBean()으로 요청할 때 전달 해준다. 아래 그림은 ApplicationContext의 사용되는 방식이다.

![](https://i.imgur.com/XEurNTm.png)

##### ApplicationContext를 사용했을때 장점

```
1. 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.
2. 애플리케이션 컨텍스트는 종합 IoC서비스를 제공해준다.
  오브젝트가 만들어지는 방식, 오브젝트에 대한 후처리, 정보의 조합 설정 방식의 다변화, 인터셉티등 오브젝트를 효과적으로 활용할 수 있는 다양한 기능을 제공한다.
3. 애플리케이션 컨텍스트는 빈을 검색하는 다양한방법을 제공한다.
  타입만으로도 빈을 검색하거나 특별한 애노테이션 설정이 되어있는 빈을 찾을 수 도 있다.
```

### 1.6 싱글톤 레지스틀와 오브젝트 스코프
DaoFactory와 @Configuratuon애노테이션을 추가해서 스프링의 애플리케이션 컨텍스트를 사용하는것의 차이점에 대해서 알아볼것이다. 둘의 큰 차이점은 리턴해주는 빈의 동일성을 보장 해주는것이다. 먼저 아례의 예제를 보자

```java
DaoFactory factory = new DaoFactory();
UserDao dao1 = factory.userDao();
UserDao dao2 = factory.userDao();

System.out.println(dao1); //springbook.dao.UserDao@118f375
System.out.println(dao2); //springbook.dao.UserDao@117a8bd
```

출력결과에서 알수 있듯이 동일성이 보장되지 않는 객체들이 출력된다. 그럼 스프링 컨테이너를 이용해서 빈을 호출해 볼 것이다.

```java
ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);

UserDao dao3 = factory.userDao();
UserDao dao4 = factory.userDao();

System.out.println(dao3); //springbook.dao.UserDao@ee22f7
System.out.println(dao4); //springbook.dao.UserDao@ee22f7
```
스프링 컨테이너 즉 ApplicationContext를 통해 생성한 오브젝트는 동일성을 보장해준다. 여러번에 걸쳐 빈을 요청하더라도 매번 동일한 오브젝트를 리턴해준다.

#### 1.6.1 싱글톤 레지스트리로서의 애플리케이션 컨텍스트
ApplicationContext는 싱글톤을 저장하고 관리하는 싱글톤 레지스트리이다. 스프링은 기본적으로 별다른 설정을 하지 않으면 내부에 생성하는 빈오브젝트를 모두 싱글톤으로 생성한다.

##### 서버 애플리케이션 싱글톤
스프링에서 싱글톤을 사용하는 이유는 스프링이 주로 적용되는 대상이 자바 엔터프라이즈 기술을 사용하는 서버 환경이기 때문이다. 물론 스프링으로 PC등에서 동작하는 독립형 윈도우 프로그램으로도 개발할수 있긴 하지만 극히 드물다.
스프링이 처음 설계됐던 대규모의 엔터프라이즈 서버환경은 서버 하나당 최대로 초당 수십에서 수백 번씩 브라우저나 여타 시스템으로부터의 요청을 받아 처리할 수 있는 높은 성능이 요구되는 환경이었다. 또 하나의 요청을 처리하기위해 데이터 액세스로직, 서비스로직, 비지니스로직,프레젠테이션로직등의 다양한 기능을 담당하는 오브젝트들이 참여하는 계층형 구조였다.
그런데 매번 클라이언트에서 요청이 들어 올때마다 각로직을 담당하는 오브젝트를 새로 만들어본다고 생각해보자. 요청 한번에 5개의 오브젝트가 새로 만들어지고 초당 500개의 요청이 들어오면 초당 2500개의 새로운 오브젝트가 생성된다. 1분이면 십오만개, 한시간이면 9백만개의 새로운 오브젝트가 만들어진다. 아무리 자바의 가비지컬렉션의 성능이 좋아졌다고 한들 이렇게 부하가 걸리면 서버가 감당하기 힘들다.
엔터프라이즈 환경에서의 서블릿은 대부분 멀티스레드 환경에서 싱글톤으로 동작한다. 서블릿 클래스당 하나의 오브젝트만 만들어 두고, 사용자의 요청을 담당하는 여러 스레드에서 하나의 오브젝트를 공유해 동시에 사용된다.
이렇게 애플리케이션 안에 제한된 수, 대개 한개의 오브젝트만 만들어서 사용하는 것이 싱글톤 패턴의 원리이다.따라서 서버 환경에서는 서비스 싱글톤의 사용이 권장된다.

##### 싱글톤 패턴의 한계
싱글통 패턴을 적용한 UserDao

```java
public class UserDao{
  private static UserDao INSTANCE;
  ...

  private UserDao(ConnectionMaker connectionMaker){
    this.connectionMaker = connectionMaker;
  }

  public static synchronized UserDao getInstance(){
    if(INSTANCE == null) INSTANCE = new UserDao(???);
    return INSTANCE;
  }
}
```
싱글톤의 단점
```
-private  생성자를 갖고 있기 때문에 상속할 수 없다.
-싱글톤은 테스트하기가 힘들다.
-서버환경에서는 싱글톤이 하나만 만들어지는것을 보장하지 못한다
-싱글톤의 사용은 전역상태를 만들 수 있기 때문에 바람직하지 못하다.
```

##### 싱글톤 레지스트리
자바의 기본적인 싱글톤 패턴의 구현 방식은 여러가지 단점이 있기 때문에 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다. 그것이 바로 싱글톤 레지스트리이다. 스프링 컨테이너는 싱글톤을 생성하고, 관리하고 공급하는 싱글톤 관리 컨테이너이기도 하다. 싱글톤 레지스트리는 스태틱메소드와 private생성자등을 사용해야하는 비정상적인 클래스가 아닌 평범한 자바 클래스를 싱글톤으로 활용하게 해준다.


#### 1.6.2 싱글톤과 오브젝트의 상태
싱글톤은 멀티스레드 환경이라면 여러 스레드가 동시에 접근해서 사용할 수 있다. 따라서 상태 관리(전역변수)에 주의 해야한다. 기본적으로 클래스내에서 전역변수를 사용하지 말아야한다. 다중 사용자의 요청을 한꺼번에 처리하는 스레드들이 동시에 싱글톤오브젝트의 전역변수를 수정하는것은 매우 위험하다. 저장할 공간이 하나 뿐이니 서로 값을 덮어쓰고 자신이 저장하지 않은값을 읽어 오거나 삭제할수있기때문이다. 물론 읽기전용의 전역변수는 사용해도좋다. 이런 변수들은 final로 선언해주는거시 안전하다. 메소드안에는 지연변수(스택 영역에 저장되어져있다)이기떄문에 메소드 호출후에 초기화된다.

#### 1.6.3 스프링 빈의 스코프
스프링 내에서 빈이 생성되고 존재하고 등의 적용되는 범위에대해 스프링에서는 이것을 스코프라고한다. 기본적으로 프로토타입,요청,세션등으로 분리하여 관리해주는 스코프 범위가 존재한다.


### 1.7 의존과계 주입(DI)
