## 템플릿
템플릿이란 바뀌는 성질이 다른 코드중에서 변경이 거의 일어나지 않으며 일정한 패턴으로 유지되는 특성을 가진 부분을 자유롭게 변경되는 성질을 가진 부분으로부터 독립시켜서 효과적으로 활용할 수 있다.

### 3.1 다시보는 초난감 DAO
UserDao에는 DB연결과 관련된 여러가지 개선작업을 했지만 예외상황에대한 처리가 아직 미흡하다. 이부분에대해서 해결하려고한다.
#### 3.1.1 예외처리 기능을 갖춘 DAO
DB커넥션이라는 제한적인 리소스를 공유해 사용하는 서버에서 동작하는 JDBC코드에는 반드시 지켜야할 원칙이 있다. 바로 예외처리이다. 정상적인 JDBC 코드의 흐름을 따르지 않고 중간에 어떤 이유로든 예외가 발생했을 경우에도 사용한 리소스를 반드시 반환하도록 만들어야 하기 때문이다. 그렇지 않으면 시스템에 심각한 문제를 일으킬 수 있다.

```java
public void deleteAll() throws SQLException{
  Connection c = dataSource.getConnetion();

  PreparedStatement ps = c.prepareStatement("delete from users");
  ps.executeUpdate();

  ps.close();
  c.close();
}
```

일반적으로 서버에서는 제한된 개수의 DB커넥션을만들어서 재상용 가능한 풀로 관리한다. DB풀은 매번 getConnection()으로 가져간 커넥션을 명시적으로 close()해서 돌려줘야만 다시 풀에 넣었다가 다음 커넥션 요청이 있을 때 재사용 될 수 있다. 그런데 위에서 Connection을 close하지 못하고 Exception이 나서 Connection이 반환되지 않고 쌓인다면 풀에 커넥션의 여유가 없어지고 리소스가 모자란다는 심각한 오류를 내며 서버가 중단 될 수 있다.

```
리소스 반환과 close()
이름으로 보면 열린것을 닫는다는 의미이지만 보통 리소스를 반환한다는 의미로 이해하는것이 좋다. Connection과 PreparedStatement는 보통 풀(Pool)방식으로 운영된다. 미리 정해진 풀 안에 제한된 수의 리소스를 만들어두고 필요할때 이를 할당하고, 반환하면 다시 풀에 넣는다 방식이다. 리소스를 항생 새로 생성하는 방식보다 풀안에 넣어두고 돌려가며 사용하는 편이 훨씬 효율적이다. 대신 사용한 리소스는 빠르게 반환해야한다. 그렇지 않으면 풀에 있는 리소스가 고갈되고 문제가 발생한다. close() 메소드는 사용한 리소스스를 풀로 다시 돌려주는 역할을 한다.
```
```java
public void deleteAll() throws SQLException{
  Connection c = dataSource.getConnetion();

 try{
   PreparedStatement ps = c.prepareStatement("delete from users");
   ps.executeUpdate();
 }catch (SQLException e){
   throw e;
 }finally{
   //널검사등, 자원 close()실행
 }
  ps.close();
  c.close();
}
```
이제 위와같이 소스를 작성하면 예외상황에서도 안전한 코드가 됐다. 하지만 누가봐도 DAO에서 Connection 해지하기위한 중복된 코드가 발생할것으로 보인다.
#### 3.1.2 분리와 재사용을 위한 디자인 패턴 적용
##### 전략 패턴의 적용
개방 폐쇄 원칙을 잘지키는 구조이면서도 템플릿 메소드 패턴(상속을 통해 구현하다보니 슈퍼클래스에 의존적이다)보다 유연하고 확장성이 뛰어난 것이, 오브젝트를 아예 둘로 분리하고 클래스 레벨에서는 인터페이스를 통해서만 의존하도록 만드는 전략 패턴이다.전략 패턴은 OCP 관점에 보면 확장에 해당하는 변하는 부분을 별도의 클래스로 만들어 추상화된 인터페이스를 통해 위임하는 방식이다.
아래의 그림은 전략 패턴의 구조를 나타낸것이다. 좌측에 있는 Context의 contextMethod()에서 일정한 구조를 가지고 동작하다가 특정 확장 기능은 Strategy인터페이스를 통해 외부의 독립된 전략클래스에 위임하는 것이다.
![](https://i.imgur.com/Kcz8D4I.png)
contextMethod()는 변하지 않는 DB 커넥션 가져오기,PreparedStatement를 만들어줄 외부 기능 호출하기, 예외처리하기등의 작업을 처리한다.

contextMethod() 역할
* DB 커넥션 가져오기
* PreparedStatement를 만들어줄 외부 기능 호출하기
* 전달받은 PreparedStatement 실행하기
* 예외가 발생하려면 이를 다시 메소드 밖으로 던지기
* 모든 경우에 만들어진 PreparedStatement와 Connection을 적절히 닫아주기

두 번째 작업에서 사용하는 PreparedStatement를 만들어주는 외부 기능이 바로 전략 패턴에서 말하는 전략이라고 볼 수 있다. 전략 패턴의 구조를 따라 이 기능을 인터페에이스로 만들어두고 인터페이스의 메소드를 통해 PreparedStatement 생성 전략을 호출해주면 된다. 하지만 여기서 주요한점은 PreparedStatement를 생성하는 전략을 호출할 때는 이 컨텍스트 내에 만들어둔 DB커넥션을 전달해야하는 점이다. 커넥션이 없으면 PreparedStatement를 만들수가 없다.
PreparedStatement를 만드는 전략의 인터페이스는 컨텍스트가 만들어둔 Connection을 전달받아서, PreparedStatement를 만들고 만들어진 PreparedStatement오브젝트를 돌려준다,

```java
public interface StatementStrategy{
  PreparedStatement makePreparedStatement(Connection c) throws SQLException;
}
```
이 인터페이스를 상속해서 실제 전략, 즉 바뀌는 부분인 PreparedStatement를 생성하는 클래스가 있다. 이바뀌는 부분만 구현해서 사용할 수 있다.

```java
public class DeleteAllStatement implements StatementStrategy{

  public PreparedStatement makePreparedStatement(Connection c) throws SQLException{
    PreparedStatement ps = c.prepareStatement("delete from users");
    return ps;
  }
}
```
위에 클래스는 확장된 PreparedStatement전략인 DeleteAllStatement가 만들어 졌다. 이것을 아래와같이 contextMethod()에 해당하는 UserDao의 deleteAll() 메소드에서 사용하면 전략패턴을 적용했다고 볼 수 있다.
```java
public void deleteAll() throws SQLException {
  try{
    c = dataSource.getConnection();
    StatementStrategy strategy = new DeleteAllStatement();
    ps = strategy.makePreparedStatement(c);

    ps.executeUpdate(); // 실행메소드
  }catch (SQLException e){
  ... // 익셉션등 자원 close 처리되어짐
}
```

하지만 전략 패턴은 필요에 따라 컨텍스트는 그대로 유지되면서 전략을 바꿔 쓸 수 있다는것인데, 하지만 위에것은 DeleteAllStatement()라고 명시적으로 고정되어있는데 뭔가 이상하다. 이것은 UserDaoFactory처럼 context를 관리할 것을 만들어줘야한다.
![](https://i.imgur.com/zCzUfyH.png)


```java
public void jdbcContextWithStatementStrategy(StatementStrategy stmt) throws SQLException{
  Connection c = null;
}
```
