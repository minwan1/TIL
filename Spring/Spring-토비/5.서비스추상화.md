# 서비스 추상화[이쪽부터는 스프링 부트로 진행됨]

## 사용자 레벨 관리 기능 추가

이장부터는 스프링 부트, JPA로 진행된다.[책에서는 Spring MVC, mybatis로진행하였으나.. 어차피 원리는 같으니.... 부트로 진행하겟다(ㅎㅎXML이 좀그래서)...]

자바에는 표준 스펙, 사용 제품, 오픈소스를 통틀어서 사용방법과 혁시은 다르지만 기능과 목적이 유사한 기술이 존재한다. 환경과 상황에 따라서 기술이 바뀌고, 그에 따른 다른 API를 사용하고 다른 스타일의 접근 방법을 따라야 한다는 건 매우 피곤한일이다.

다음장에서는 스프링이 어떻게 성격이 비슷한 여러 종류의 기술을 추상화하고 이를 일관된 방법으로 사용할 수 있도록 지원하는지 확인할것이다.

### 5.1 사용자 레벨 관리 기능 추가
이전까지는 DAO를 이용해 간단한 CRUD를 진행했는데 이장부터는 약간의 비지니스로직을 추가할것이다. 내용은 다음과 같다.
* 사용자의 레벨은 BASIC, SILVER, GOLD 세가지중 하나이다.
* 사용자가 처음 가입하면 BASIC 레벨이 되며, 이후 활동에 따라서 한단꼐씩 업그레이드 될 수 있다.
* 가입 후 50회 이상 로그인을 하면 BASIC에서 SIRVER레벨이 된다.
* SILVER레벨이면서 30번 이상 추천을 받으면 GOLD레벨이 된다.
* 사용자 레벨의 변경 작업은 일정한 주기를 가지고 일관적으로 진행된다. 변경 작업전에는 조건을 충족하더라도 레벨의 변경이 일어나지 않는다.

사용자 관리의 기본 로직은 정해진 조건에 따라 사용자의 레벨을 주기적으로 변경한다이다.

#### 5.1.1 필드 추가
```java
public class User {

    private static final int BASIC = 1;
    private static final int SILVER = 2;
    private static final int GOLD = 3;

    private int level;

    public void setLevel(int level){
        this.level = level;
    }
}
```
먼저 위와같은 코드로 유저의 레벨을 관리한다고 해보자. 예전같으면 위와같이 상수로 레벨들을 관리 했을 수 있다. 하지만 상수로 관리하게 되면 많은 문제들을 가지고 있다. 먼저 실수로 다른 인트값이 들어간다고해도 같은 인트형 타입이기 떄문에 숫자가 들어가진다. 이러한문제로인해 3이상의 값이 들어간다고해도 컴파일러단에서 에러는 나지않을것이다. 이러한문제는 심각한 문제를 만들어낸다.
하지만 이러한 문제를 컴파일단계에서 막을 수 있는 방법이 있다. 그것은 바로 아래와같은 enum타입이다. enum은 같은 타입은 타입을 선언하기때문에 안전하게 사용할 수 있다.

```java
public enum Level {
    BASIC(1),
    SILVER(2),
    GOLD(3)
    ;

    private final int value;

    Level(int value){
        this.value = value;
    }

    public int value(){
        return value;
    }
}
```
그다음 다음과 같이 유저를 선언한다.
```java
@Getter
@Entity
@NoArgsConstructor
public class User {

  @Id
  private String id;
  private Level level;
  private int login;
  private int recommed;


    @Builder
    public User(Level level, int login, int recommed) {
        this.level = level;
        this.login = login;
        this.recommed = recommed;
    }
}
```

그다음 다음과 같이 컬럼을 추가한다. 그리고 hibenate에서 다음과같이 설정을 키고 그냥 실행시키면 알아서 컬럼들을 생성해준다. 물론 로컬이나 h2디비를 붙인 후 결과이다.
```
jpa:
    hibernate:
      ddl-auto: update
```
셋팅은 위와같이 다끝내고, 우선 책에서는 디비를 이용했지만 예제에서는 하드코딩으로 유닛 테스트를 만들어 간단하게 테스팅이 잘되는지 확인해보자.

```java
@Test
public void addAndGet() {
    User user = new User().builder()
            .id("test")
            .level(Level.BASIC)
            .login(1)
            .recommed(1)
            .build();

    User user1 = userDao.get(user.getId());
    checkSameUser(user, user1);
}

private void checkSameUser(User user, User user1) {
    Assert.assertThat(user.getId(), CoreMatchers.is(user1.getId()));
    Assert.assertThat(user.getLevel(), CoreMatchers.is(user1.getLevel()));
    Assert.assertThat(user.getRecommed(), CoreMatchers.is(user1.getRecommed()));
}
```
테스트가 어느정도 잘된것같다. 책에서느 에러가 좀나는데 역시 jpa가 편하다. 그냥 컴파일러전에 에러를 다잡아주거나 간단한 설정만으로 타입세이프하니까.....

#### 사용자 수정 기능 추가
사용자 관리 비즈니스로직에 따르면 사용자 정보는 여러 번 수정될 수 있다. 이과정에서 사용자 기능은 계속 반복적으로 다른 클래스들에서도 호출될 수 있으니 UserService를 생성한다. 그리고 UserService에서 유저에관한 비지니스로직을 다룰것이다.

```java
public class UserService {

    private UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    ....
}
```

```java
@Bean
public UserService userService(){
      return  new UserService(userRepository);
  }
```
먼저 앞에서 말한대로 UserService를 생성하고 그곳에서 영속성에 접근할 수 있게 userRepository를 DI해줬다. 위와같이 등록하게되면 이제 스프링 컨테이너가 userService를 관리할 수 있게되고 아래와같이 변수로 접근할 수 있다.

```java
@Autowired
private UserService userService;
```

이제 수정 메소드도 추가했으니 다음은 유저를추가하는 add()메소드를 넣어보자. 이메소드는 어디에 넣는게 좋을까. 그렇다 UserService에 넣어야할것같다. 왜냐 지금 user에관한 관심이 userService에 집중되고 있기 때문이다.

##### 사용자 레벨 업 기능(upgradeLevels) 리팩토링
다음은 사용자 접속에 따른 userService에 레벨업 기능을 구현해보자. 아래와같이 level과 방문 횟수에따라 레벨이 결정되고, 변경여부에따라 유저가 업데이트된다. 책은 mybatis라서 업데이트를 쳐줘야하는데 mybatis같은경우에는 영속성이 존재하기 때문에 그냥 수정만해줘도 유저 정보가 수정된다. 하지만 후에 있을 리팩토링 예제를 따르기위해서 다음과같이 소스를 짯다.

```java
public List<User> upgradeLevels(){
        List<User> users = (List<User>) userRepository.findAll();
        for(User user : users){
            boolean changed = false;

            if(user.getLevel() == Level.BASIC &&user.getLogin() >= 50){
                user.updateLevel(Level.SILVER);
                changed = true;
            }
            else if(user.getLevel() == Level.SILVER &&user.getLogin() >= 30){
                user.updateLevel(Level.GOLD);
                changed = true;
            }else if(user.getLevel() == Level.GOLD){
                changed = false;
            }else{
                changed false;
            }

            if(changed){
                userRepository.save(users)
            }
        }

        return users;
    }
```


##### 코드 개선
비지니스로직이 완성되고 기능이 정상적으로 완료됬다고해서 개발이 끝난게아니다. 리팩토링을 해야하한다. 리팩토링은 선택사항이 아니라 필수사항이다. 그러기위해서는 다음과같은것들을 체크해야한다
1. 코드에 중복된 부분은없는가
2. 코드가 무어을 하는것인지 이해하기 불편하지 않은가?
3. 코드가 자신이 있어야할 자리에 있는가 ?
4. 앞으로 변경이 일어난다면 어떤것이 있을 수 있고, 그변화에 쉽게 대응할 수 있는가?

**upgradeLevels 문제점**
일단 for 루프속에 들어있는 if/elseif/else 블록들이 읽기 불편하다. 레벨의 변화 단계와 업그레이드조건, 조건이 충족됐을 때 해야 할 작업이 한데 섞여 있어서 로직을 이해하기 어렵다.

코드가 깔끔해보이지 않는 이유는 이렇게 성격이 다른 여러가지 로직이 한데 섞여 있기 때문이다.
```java
if(user.getLevel() == Level.BASIC &&user.getLogin() >= 50){
    user.updateLevel(Level.SILVER);
    changed = true;
}
...
if(changed){
    userRepository.update(users); // UserRepository에는 update가없다.
}
```
흐름
1. 현재 레벨이 무엇인지 파악하는 로직이다.
2. 업그레이드 조건을 담은 로직이다.
3. 다음 단계의 레벨이 무엇이면 업그레이드를 위한 작업이 무엇인지 플래그하는게있다.
4. 플래그를 이용한 업데이트

유저 레벨에 업그레이드라는 관심사항이 모여있는것같지만 성격이 조금씩 다른 것들이 섞여 있거나 분리돼서 나타나는 구조다. 이런 if 조건 블록이 레벨 개수 만큼 반복된다고 생각하면 엄청난 if문이 생길거고 경우의 수가 엄청나게 복잡 해질것이다. 이렇게 소스가 지저분해지면 버그가 발생한다면 아주 큰일일것이다.

**upgradeLevels 리팩토링**
이제 코드를 리팩토링 해볼것이다. 가장 먼저 추상적인 레벨에서 로직을 작성해보자. 기존의 upgradeLevels()메소드는 자주 변경될 가능성이 있는 구체적인 내용이 추상적인 로직의 흐름과 함께 섞여 있다.
먼저 구체적인 내용과 추상적인 로직을 분리해서 생각해보자. 일단 유저의 level을 업그레이드 하는것이다. 이것을 진행하기위해서는 다시생각해보면 다음과 같을 수 있다
1. 유저 레벨을 업그레이드한다.
2. 모든 유저를 조회해온다.
3. 유저는 업그레이드 할 수 있는가?
4. 업그레이드한다.
어떻게보면 다음과 같은 기능인데 소스가 엄청 난잡해졌다. 그럼 방금 말한대로 소스를 고쳐보겠다.
```java
public void upgradeLevels(){
  List<User> users = (List<User>) userRepository.findAll();
  for(User user : users){
    if(canUpgradeLevel(user))
      upgradeLevel(user);

  }
}
```
그렇다 정말 간단해졌다. 이제 여기에따라 구체적인 내용을 담은 메소드를 만들면된다.
```java
private boolean canUpgradeLevel(User user){
    Level currentLevel = user.getLevel();
    switch (currentLevel){
        case BASIC: return (user.getLogin() >= 50);
        case SILVER: return (user.getLogin() >= 30);
        case GOLD: return false;
        default: throw new IllegalArgumentException("Unknown Level");
    }
}
```
위와같이 선언하게되면 역할과 책임이 명료해진다. 업그레이드가 가능한지 확인하는 방법은 User 오브젝트에서 레벨을 가져와서, switch문으로 레벨을 구분하고, 각 레벨에 대한 업그레이드 조건을 만족하는지를 확인해주면된다.
다음은 레벨 업그레이드 작업메소드이다.
```java
private void upgradeLevel(User user){
    if(user.getLevel() == Level.BASIC) user.updateLevel(Level.SILVER);
    else if(user.getLevel() == Level.SILVER) user.updateLevel(Level.GOLD);
    userRepository.save(user);
}
```

하지만 여기에서 upgradeLevel메소드 한번더 세분화 할 수 있다. 마음에 안드는 점은 다음단계가 무엇인가하는 로직과 그때 사용자 오브젝트의 level필드를 변경해준다는 로직이 함께 있는데다, 너무 노골적으로 드러나 있다. 거기에다가 골드 이상에 등급이 들어온다면 Exception 발생할것이다.
먼저 레벨의 순서와 다음 단계 레벨이 무엇인지를 결정하는 일은 Level에게 맡기자.

```java
public enum Level {
    GOLD(3, null),
    SILVER(2, GOLD),
    BASIC(1, SILVER),
    ;

    private final int value;
    private final Level next;

    Level(int value, Level next){
        this.value = value;
        this.next = next;
    }

    public int value(){
        return value;
    }

    public Level nextLevel(){
        return this.next;
    }
}
```
다음과같이 level 관한 책임은 레벨객체에게 넘기면 된다. 이렇게하면 if문으로 레벨을 체크할필요도없이 nextLevel함수를 호출하게되면 다음 레벨로 객체가 변하게 된다.

```java
//user객체
public void updateLevel(Level level){
        final Level nextLevel = level.nextLevel();
        if(nextLevel == null){
            throw new IllegalStateException(this.level + "은 업그레이드가 불가능합니다.");
        }else{
            this.level = nextLevel;
        }
    }
```
이제 유저의 레벨을 올리기위해서는 user에게 시키면되고, 그 레벨의 관리 책임도 유저가 가지게된다. 이렇게되면 훨씬 코드를 읽기 편해진다.

```java
private void upgradeLevel(User user){
    user.updateLevel();
    userRepository.save(user);
}
```
이렇게함으로 훨씬더 가독성 좋은 코드가 되었다.

지금 개선한 코드를 살펴보면 각 오브젝트와 메소드가 각각 자기 몫의 책임을 맡아 일을 하는 구조로 만들어졌음을 알 수 있을 것이다. 객체지향적인 코드는 다른 오브젝트의 데이터를 가져와서 작업하는 대신 데이터를 갖고 있는 다른 오브젝트에게 작업을 해달라고 요청한다. 오브젝트에게 데이터를 요구 하지말고 작업을 요청하라는 것이 객체 지향 프로그래밍의 가장 기본이 되는 원리이기도 하다.


## 트랜잭션 서비스 추상화
