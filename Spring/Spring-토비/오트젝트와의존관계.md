## 1장 오브젝트와 의존관계
스프링은 자바 엔터프라이즈 기술의 혼란속에서 잃어버렸던 객체지향 기술의 진정한 가치를 회복시키고 폭넓은 혜택을 누릴수있도록하는것이 스프링 철학이다. 그래서 스프링에서 관심을 많이두는것은 오브젝트의 생명주기이다. 오브젝트 생명관리를 통해 재활용 가능한 설계방법의 디자인패턴, 좀 더 깔끔한 소스구조이다.

### 1.1 초난감 DAO
JDBC를 이용한 User CURD를 다루는 UserDAO생성.
### 1.2 DAO 분리

#### 1.2.1 커넥션만들기의 추출
항상 미래를 내다보고 설계해야한다. 중복된 코드가 무엇인지에대해 생각하여야한다. 초난감 DAO에서 가장 먼저 할일은 커넥션을 가져오는 중복된 코드를 분리하는 것이다. 중복된 부분을 getConnetion 메소드로 빼서 연결이 필요할때는 그메소드를 호출하는것이다.
```java
public User get(String id)  throws ClassNotFoundException,SQLException{
  Connection c = getConnetion();
}

private Connection getConnection() throws ClassNotFoundException,SQLException{
  class.forName("com.mysql.jdbc.Driver");
  Connection C = DriverManager.getConnection("jdbc:mysql://localhost/springbook","spring",book);
  return c
}
```
위에 getConnection메소드는 관심의 종류에 따라 코드를 구밴 해놓았기 때문에 한가지관심 예를들어 데이터베이스의 종류를 바꾼다든지 그런 문제에서 하나의 메소드만 변경하게 되면 손쉽게 데이터 베이스를 바꿀수 있게 해준다.위 코드로 인하여 다른 get메소드같은데에는 영향을 끼치지 않는다.
위에 초난감 DAO를 리팩토링 했는데 리팩토링은 객체지향 개발자라면 반드시 익혀야하는 기법이다.

#### 1.2.2 DB커넥션 만들기의 독립
이번에는 좀더 변화를 반기는 DAO를 만들것이다.
##### 상속을 통한 확장
![](https://i.imgur.com/Ux1nXhz.png)
위그림과 같이 UserDao를 추상클래스로 선언 하면 좀더 확장성 있는 소스가 될 것이다. 이렇게 선언하게되면 추상클래스에 add와 get만 메소드를 구현하고 getConnection은 깡통메소드로 나두게되면 NUserDao,DUserDao에서 getConnection만 구현하게되면 2개의 각기 다른 디비를 붙일 수 있다. 이렇든 UserDao와같은 슈퍼클래스는 기본적인 로직의 흐름(커넥션가져오기,sql생성,실행,반환)만들고 서브클래스는 메소드를 구현하는 패턴을 템플릿 메소드 패턴이라고 한다. 템플릿 메소드 패턴은 스프링에서 애용하는 패턴이다.



1.3 DAO의 확장
![](https://i.imgur.com/ZBKuVCa.png)
인터페이스를 통해서 위와같은 불필요한 의존관계를 끊어줘야한다

```java
public interface ConnectionMaker {
    public Connection makeConnection() throws ClassNotFoundException, SQLException;
}

public class DConnectionMaker implements ConnectionMaker {
    public Connection makeConnection() throws ClassNotFoundException, SQLException {
        // D 사의 독자적인 방법으로 Connection 을 생성하는 코드
    }
}
public class UserDao {
    private ConnectionMaker connectionMaker; ㅡ> 인터페이스를 통해 오브젝트에 접근, so 구체적 클래스 정보가 필요 없다.

    public UserDao(ConnectionMaker connectionMaker){
        this.connectionMaker = connectionMaker;  
    }

    public void add(User user) throws ClassNotFoundException, SQLException {
        Connection c = connectionMaker.makeConnection();
      ㅡ> 인터페이스에 정의된 메소드를 사용하므로 클래스가 바뀐다고 메소드 이름이 변경 되지 않는다.
    }

    public user get(String id) throws ClassNotFoundException, SQLException {
        Connection c = connectionMaker.makeConnection();
    }
}

```

UserDaoTest
```java
public class UserDaoTest{
    public static void main(String[] args) throws ClassNotFoundException, SQLException {
        ConnectionMaker connectionMaker = new DConnectionMaker();
        // UserDao가 사용할 ConnectionMaker 구현 클래스를 결정하고 오브젝트를 만든다.

        UserDao dao = new UserDao(connectionMaker);
        // 1. UserDao 생성
        // 2. 사용할 ConnectionMaker 타입의 오브젝트 제공, 결국 두 오브젝트 사이의 의존관계 설정
    }
}
```

최종적으로 UserDaoTest와같이 UserDao를 즉 3자 호출하는곳에서 의존성 주입을하게되면 아래와같이 불필요한 의존관계를 끊을 수 있게된다. 이렇게되면 D사,N사에서 UserDao를 구현할필요없이 N사와 D사는 ConnectionMaker인터페이스의 Connection만 구현해주게되면 N사와 D사는 UserDao클래스를 신경쓸 필요가 없게 된다.
![](https://i.imgur.com/gX6THnw.png)
