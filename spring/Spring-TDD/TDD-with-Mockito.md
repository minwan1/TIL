#Junit

# Unit test 얘기

단위 테스트를 작성하다보면 처음에 설계할 때 미쳐 생각하지 못했던 논리적인 오류들을 잡을 수 있게 해준다.



소프트웨어의 테스트 가능한 가장 작은 단위의 코드를 테스트하는 기법입니다. 개체지향 프로그래밍(object-oriented programming)에서는 주로 클래스나 메서드가 테스트 대상입니다. 일반적으로 하나의 테스트 대상에 대해서 세부적인 논리별로 각각 테스트 케이스를 작성합니다.


Mockito라는것을 이용하면 외부 플랫폼에 종속적이지 않게 된다. 예를들어 테스트를 하기 위해서 데이터베이스가 필요하거나 외부 api를 호출해야한다면 이러한 요청은 외부 플랫폼에 의존적이여야 한다. 하지만 Mockito 프레임워크를 이용하면 쉽게 목데이터를 만들어 테스트 할 수 있다.

통합 테스트오 달리 Unit test는 하나의 클래스에 초점을 맞쳐 테스트해야만한다.



## 목
목은 우리가 테스트하는 과정에서 이메일이 나가지 않거나 데이터베이스와 같은 외부 시스템 데이터베이스 연결에 의존하지 않게 해주는 아주 유용하다.






#통합 테스트

충분히 단위 테스트 되어진 코드들이라도 상호작용에 의해 문제가 발생할 수 있고, 데이터베이스 제약조건등에서 문제가 발생 할 수 있습니다.





## TDD

구현하고자 하는 아주 작은 기능 하나를 정의 또는 선택한 후 이 기능을 검증하는 테스트 케이스를 작성하고 작성된 테스트 케이스가 대상 기능이 구현되지 않은 이유로 실패하는지 확인한다.
전 단계에서 작성된 테스트 케이스를 비롯해 모든 테스트 케이스가 성공하도록, 그리고 성공할 만큼만 기능 코드를 작성한다.
모든 테스트 케이스가 성공하는 것을 확인하며 코드를 리팩터 한다.
이 과정을 흔히 Red-Green-Refactor라고 부른다.






## 리팩토링을 두려워할수록 코드는 썩어들어가진다.



1.실패
2.해결
3.개선



1. 억지로 실패하게 한다 ?



픽스처(테스트를 수행하는데 필요한 정보나 오브젝트를 픽스처(fixture)라고 한다.
테스트를 위한 애플리케이션 컨특세트 관리


@RunWith(SpringJUnit4ClassRunner.class) // Spring 테스트 컨텍스트 프레임워크의 JUnit확장 기능 지정
@ContextConfiguration(classes={DaoFactory.class}) // 테스트 컨텍스트가 자동으로 만들어줄 어플리케이션 컨텍스트의 위치




<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-core</artifactId>
    <version>2.8.9</version>
</dependency>




## TextContext

일반적으로 스프링의 구조는 Controller - Service - DAO의 구조이다. 이런상황에서 컨트롤러 테스트할 때에는 테스트하는 범위를 기준으로 테스트를 크게 두가지로 나눌 수 있다.
* 컨트롤러 클래스 단위 테스트
* 컨트롤러 클래스 통합 테스트



테스트를 하고자 하는 대상이 명확하다면 그 대상에만 집중해서 테스트하는 것이 바람직하다. 테스트는 가능하면 작은 단위로 쪼개서 집중해서 할 수 있어야 한다. 관심사의 분리라는 원리가 여기에도 적용된다. 테스트의 관심이 다르다면 테스트할 대상을 분리하고 집중해서 접근해야한다.






# Junit
JUnit은 사실상 자바의 표준 테스팅 프레임워크라고 불릴만큼 폭넓게 사용되고 있다. 스프링의 핵심 기능 중 하나인 스프링 테스트 모듈도 JUnit을 이용한다. 또, 테스트 작성시 자주 필요한 편리한 여러 가지 부가기능도 제공한다



## 
통계적으로 나온건건데 보통 버그를 고치기위해 한라인을 고치면 3군대에서 버그가 나온다.

대부분에 버그는 버그를 수정하다가 고치다가 버그가 나오는 경우가 많음.





전반적인 단위테스트 예제좋네

https://memorynotfound.com/unit-test-spring-mvc-rest-service-junit-mockito/