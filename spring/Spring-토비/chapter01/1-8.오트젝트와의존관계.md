### 1.8 XML을 이용한 설정
#### XML설정
스프링은 DaaFactory같은 자바 클래스를 이용하는것 외에도, 다양한 방법을 통해 DI의존관계 설정 정보를 만들 수 있다. XML이 그 대표적인 예이다. XML 설정은 @Configuration과 @Bean이 붙은 자바 클래스로 만든 설정과 내용이 동일하다. 간단하게 예제를 하나 만들어보겠다.
```java
@Bean <bean
public ConnectionMaker connectionMaker(){ id="connectionMaker"
  return new DConnectionMaker(); class="wan.test.DConnectionMaker" />
}
```
UserDao의 수정자를 수정하는 예제를 만들어보겠다.

```java
userDao.setConnectionMaker(connectionMaker());
<property name="connectionMaker" ref="connectionMaker">
```
userDao의 수정자를 빈을 생성한후 등록하는것을 xml로 구현하겠다
```xml
<bean id="userDao" class="springbook.dao.UserDao">
  <property name="connectionMaker" ref="connectionMaker" />
  <!-- name은 setConnectionMaker를 의미 ref는 객체라고 생각하면됨 -->
</bean>
```

떄로는 아래 소스와 같이 XML을 이용해 인터페이스를 구현한 의존 오브젝트를 여러개 정의해두고 그중원하는 DI를 사용할 수 있다.

```xml
<beans>
  <bean id="localDBConnectionMaker" class="...LocalDBCOnnectionMaker" />
  <bean id="testDBConnectionMaker" class="...TestDBConnectionMaker" />
  <bean id="productionDBConnectionMaker" class="...ProductionDBConnectionMaker" />

  <bean id="userDao" class="springbook.user.dao.UserDao">
    <property name="connectionMaker" ref="localDBConnectionMaker" />
    <!--  connectionMaker는 setConnectionMaker(수정자)다 다시한번강조. -->
  </bean>  

</beans>
```
위와 같이 미리 구현체빈을 등록해놓고 빈을 교체하면서 사용할 수 있다.

#### 1.8.2 XML을 이용하는 애플리케이션 컨텍스트
이제 XML의 방식을 사용하기 위해서는 기존 @Configuration으로 설정하던 DaoFactory 설정 정보대신 applicationContext를 만들어서 사용해야한다. 그리고 기존의 빈의 의존관계를 이용하기위해 사용했던 AnnotationConfigApplicationContext대신 GenericXmlApplicationContext를 이용해 사용하 수 있다. 생성자 파라미터로는 applicationContext의 위치를 넘기면된다.
```java
ApplicationContext context = new GenericXmlApplicationContext("applicationContext");
```
이외에 ClassPathXmlApplicationContext의 기능을 이용해 가져오는경우도 있다, 참고해두면 좋을것같다.

#### 1.8.3 DataSource 인터페이스로 변환
일반적으로 DataSource를 구현해서 DB커넥션을 제공하는 클래스를 만들 일은 거의 없다. 이미 다양한 방법으로 DB연결과 풀링 기능을 갖춘 많은 DataSource구현 클래스가 존재하고, 이를 가져다 사용하면 충분하기 때문이다. 대부분의 DataSource 구현 클래스는 DB의 종류나 아이디, 비밀번호 정도는 DataSource 구현클래스를 다시 만들지 않고도 지정할 수 있는 방법을 제공한다. 기존의 우리가 사용하던 ConnectionMaker의 makeConnection()과 동일한 메소드또한 DataSource의 getConnetion()메소드가 존재한다. Dao에서는 DataSoure의 getConnection 메소드를 사용해 DB커넥션을 가져오면 된다.

```java
public interface DataSource extends CommonDataSource,Wrapper{
  Connection getConnetion() throws SQLException;
}
```
DataSource 인터페이스와 다양한 DataSource 구현 클래스를 사용할 수 있도록 UserDao를 리팩토링 해보자.

```java
public class UserDao{
  private DataSource dataSource;

  public void setDataSource(DataSource dataSource){
    this.dataSource = dataSource;
  }

  public void add(User user) throws SQLException{
    Connection c = dataSource.getConnetion();
  }
}
```
DataSource 빈등록 configuration (java형식)
```java
public DataSource dataSource(){
  SimpleDriverDataSource dataSource = new SimpleDriverDataSource();

  dataSource.setDriverClass(com.mysql.jdbc.Driver.class);
  dataSource.setUrl("jdbc:mysql://localhost:3306/wan");
  dataSource.setUsername("root");
  dataSource.setPassword("1234");
  return dataSource;
}
```
xml 방식
```xml

<property name="driverClass" value="com.mysql.jdbc.Driver" />
<property name="url" value="jdbc:mysql://localhost:3306/wan" />
<property name="username" value="root" />
<property name="password" value="1234" />
```
### 정리
이번장에 목적
- 관심사 분리(관심사의 클래스르 분리)
- 인터페이스를 정의하여 구현방법이 달라져도 그 기능을 사용하는 클래스의 코드는 같이 수정할 필요가없도록함(전략패턴)
- 오브젝트를 생성되고 관계를맺는 제어권을 별도의 오브젝트 팩토리로 만들었다.
