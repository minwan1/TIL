# 스프링 배치 도입
많은 엔터프라이즈 에플리케이션에서 중요한환경에 작업들을 처리하기위해 대량에 처리를 한번에 할필요가 있다. 이러한 비지니스적 작업들은 유저에 처리 없이 자동화되어 많은 양의 작업들이 한번에 처리되는것을 의미한다. 이러한 작업들은 대부분 시간 기반이다.(달 계산, 통지, 응답) 배치처리는 하루에 수백만건의 트랜잭션들을 처리하기위해 사용되어진다. 스프링 배치는 가볍고 종홥적고 일상적인 엔터프라이즈 시스템들에서 튼튼한 배치를 처리하기위해 설계되어졌다. 스프링배치는 스케줄링 프레임워크는 아니다. 많은 엔터프라이즈급 스케줄러들이 존재한다. 예를들어 오픈서스 기반에 쿼츠, Tivoli, Control-M 등이 있다. 배치는 스케줄러를 대체하는게 아닌 결합하여 사용하는것이다.

스프링 배치는 많은양의 작업처리, 기록, 로그처리, 트랜잭션관리, 잡통계처리, 잡 재시작, 스킵, 자원관리등을 해준다. 

## BackGround
기존 오픈소스나 커뮤니티들은 SOA기반의 메시징기반에 초점을 맞췄었다. IT환경에 지속적으로 재사용가능한 배치처리가가 필요함에도 불구하고 이러한것들은 부족했었다. 이러한 재사용가능한 배치작업 표준이 없어기때문에 모든 사람들은 1회성 배치잡을 만들어 사용했다.

SpringSource 그리고 Accenture 는 콜라보하여 배치를 내놨다. 이 배치는 추가적인 상세사항 그리고 실제 제약조건의 문제들을 해결해줄 수 있는것들을 제공한다. 이러한 정교한 스프링 배치로인해 회사들 그리고 정부 대해생사들은 이러한 배치 표준으로인해 혜택을 누릴것이다.

## 사용 시나리오
일반적으로 배치프로그램들의 사용방법은 데이터베이스, 파일등으로부터 기록된 데이터들을 읽어와 그것을 수정을 하고 저장한다. 스프링 배치는 유저에 관여 없이 같은 트랜잭션에 집합을 처리화하는것이 자동화 되어있다.

### 비지니스 시나리오
* 정기적인 배치프로세스 커밋
* 동시성 배치처리 : 병렬 작 처리
* 실환경, 기업용 메시지 드리븐 처리
* 대량의 병렬 배치 처리
* 배치처리 실패후에 자동  또는 수동으로 재배치 실행
* 부분 처리 : 몇몇의 기록들은 롤백 처리
* 전체 배치 트랜잭션 처리 : 소규모 배치, 프로시저들을 위한 처리

### 기술적인 목적
* 배치 개발자들은 스프링 프로그래밍 모델을 사용한다. : 개발자는 비지니스로직에 집중하고 배치에대한 전체적인 인프라는 스프링이 처리한다.
* 배치 어플리케이션, 배치 실행환경, 인프라사이에 명확한 문제 구분
* 모든 프로젝트들이 구현할 수 있는 코어, 공통 실행 서비스들을 제공
* 스프링 프레임워크에 모든 레어들을 사용함으로써 쉬운 구성, 커스터마이징, 확장이 용이함.
* 모든 코어서비스들은 익프라스트럭처(스프링배치)에 영향없이 쉽게 교체 되어져야한다.
* 간단한 배포모델을 제공해야함


## 스프링 배치 아키텍처
스프링 배치는 확장 가능하고 다양한 그룹에 유저들이 사용할 수 있도록 설계 되어졌다. 아래는 스프링 배치의 아키텍처 레이어를 보여준다.

![](https://docs.spring.io/spring-batch/trunk/reference/htmlsingle/images/spring-batch-layers.png)

이아키텍처는 3개의 레벨에 컴포넌트를 강조한다. 
Application 영역은 스프링 배치를 사용하여 개발자들로부터 작성되어진 커스텀 코드, 배치잡들이 작성되어 있다. 

Bach Core는 배치잡을 제어하고 실행하기위한 컴포넌트이다. 대표적인 클래스들은 `JobLancher`, `Job`, `Step`이 들어있다.  

Application과 Bach Core는 인프라 영역위에 만들어진다. 인프라 영역은 공통적인 Reader, Writer, RetryTemplate같은 서비스들을 제공한다. 이것은 개발자들로부터 사용된다(`ItemReader`, `ItemWriter`, `RetryTemplate`)

## 일반적인 배치 원리와 가이드라인

다음은 스프링 배치에 몇몇에 주요 원리 및 가이드라인, 일반적인 고려사항에 대한 설명입니다.

* 배치아키텍처는 온라인 그리고 오프란 아키텍처에 영향을 받는다. 가능한 공통적인 빌딩 블록들을 고려하여  설계해야한다.
* 배치를 만들떄 최대한 간단하게하시고 복잡한 로직은 피해야한다.
* 물리적으로 데이터가 가까운곳에서 처리하세요(무슨말이지)
* 최대한 I/O를줄이고 내부 메모리에서 작업을 해야한다.
* 다음과 같은 상황이 발생했을떄 불필요한 I/O가 일어나지 않게 다음 주의 사항을 명심하세요
* 일괄처리를 두번 실행하지말아야한다. 
* 배치처리레 충분한 메모리를 할당해야한다.
* 실제 프로덕션 레벨에서 테스트할 데이터들을 가능한한 쉽게 테스트 할 수 있는 환경들을 만들고 테스트해야한다.
* 


## 배치 처리 전략들
기본 배치 어플리케이션 패터들은 차트등으로 개발자나 설계자에게 제공되어야한다. **배치잡이 설계되기 시작했을 때 비지니스 로직은 아래의 표준 빌딩 블록들을 사용하여 구현될 수 있는 `단계`들로 분해 되어야한다.**

* 변환 어플리케이션
외부 시스템으로부터 제공되거나 생성되어진 파일들의 거래 기록들을, 변환 어플리케이션은 거래기록에 대해 작업 처리를 위해 요구되어진 포멧으로 전처리를 해줘야 한다. 이러한 타입에 배치 어플리케이션은 부분적으로 전체적으로 변환 유틸 모듈로 구성될 수 있다(Base Batch Service들을 참고하세요)

* 검증 어플리케이션
검증 어플리케이션은 모든 입출력 데이터드들이 정확한지 일관성이 있는지 확인처리를 한다. 검증은 또한 데이터에 무결성을 검증한다.

* 추출 어플리케이션
미리 정의되어진 규칙에 따라 파일또는 데이터베이스로부터 읽어 들여 출력파일에 데이터를 쓰는 어플리케이션

* 추출/갱신 어플리케이션
파일 또는 데이터베이스로부터 읽거나 읽어들인 데이터드들 수정하는 어플리케이션

* 처리/ 갱신 어플리케이션
추출 또는 검증어플리케이션부터 얻은 데이터들을 처리를 수행하는 어플리케이션이다. 작업을 위해 필요로하는 데이터를 읽고 데이터베이스에 데이터들을 업데이트하거나 만드는 작업을 한다.

위에서 업그되어진 목록으로 만들어질 수 없는 비지니스 로직은 Shell을 이용하여 제공되어야한다.


또한 메인 빌딩 블록은 아래와 같이 기존 표준 유틸리티로써 하나이상의 스텝을 가질 수 있다

* Sort
입력파일들을 읽고 그 기록들을 다시 필드에 따라 재 정렬한 파일들을 생성한다. 정렬들은 표준 시스템 유틸리
* Split
입력파일들을 읽어 출력파일에 각각 기록물들에 따라 출력파일들을 생성한다. 
* Merge
여러개의 파일들로부터 데이터들을 읽어 하나의 파일로 병합한다. 이러한 병합 조건은 파라미터하 조건하에 병합되어질 수 있다.

배치 어플리케이션은 입력자원에 따라서 추가적으로 그룹화 되어질 수 있다. 

* 데이터베이스로 검색되어진 데이터들로부터 주도되어질 수 있다.
* 파일에서부터 검색되어진 데이터들로부터 주도되어질 수 있다.
* 메시지큐들로부터 보내진 데이터로부터 주도되어질 수 있다.

**배치 시스템에 핵심은 처리 전략입니다.** 이러한 전략 선택에 영향을 받는것은 다음과 같은 요소이다. 예상가능한 처리량, 오라인 또는 다른 배치시스템과의 동시성

배치처리에 전형적인 옵션들이다.
* 일반적인 배치처리
* 동시성 배치처리
* 같은 시간에 배치 또는 잡들을 병렬처리하는 작업
* 분할처리(많은 인스턴스 사이에 배처처리)
* 혼합 처리


배치의 옵션들은 몇몇의 상업적 스케줄러로부터 보조되어진다. 이러한 처리에대한 옵션들은 다음 섹션에서 좀더 상세히 설명되어진다. 배치프로세스로부터 채택 되어진 락전략 또는 커밋전략은 수행되어지는 프로세싱 타입으로부터 의존할것이다. 

잠금 전략은 일반적인 데이터베이스만 사용가능하다 또는 추가적인 커스텀 잠금 서비를 구현해서 사용할 수 있다. 잠금 서비스는 잠금 전용디비에  필요한 정보를 저장함으로써 추적가능할것이다. 또한 재시도 로직이런것들이 필요할것이다.


**1. Normal processing in a batch window**
동시성에 문제가 되지 않는 즉 유저들로부터 또는 다른 배치로부터 동시에 데이터를 처리하지 않는 일반적인 배치 방법이 있을것이다.
**대부분의 배치는 시간이나 데이터 양이 증가함에따라서 복잡성이 증가한다. 잠금 전략이 없이 단일커밋에 의존한다면 후에 고생할 일이 생기게 된다.** 간단한 전략을 가지세요.

**2. Concurrent batch / on-line processing**
유저 또는 다른 배치로부터 요구되어질 수 있는 데이터는 잠금 처리를 하면 안된다. 이러한 갱신은 트랜잭션들이 끝날때마다 커밋되어져야한다. 

물리적인 락킹을 제외한 데이터를 잠금는 방법으로는 Optimistic Locking Pattern과 Pessimistic Locking Pattern이 존재한다.


# 참고

https://docs.spring.io/spring-batch/trunk/reference/htmlsingle/